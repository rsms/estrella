{
  "version": 3,
  "sources": ["node_modules/miniglob/miniglob.js", "node_modules/picomatch/lib/constants.js", "node_modules/picomatch/lib/utils.js", "node_modules/picomatch/lib/scan.js", "node_modules/picomatch/lib/parse.js", "node_modules/picomatch/lib/picomatch.js", "node_modules/picomatch/index.js", "node_modules/readdirp/index.js", "node_modules/normalize-path/index.js", "node_modules/anymatch/index.js", "node_modules/is-extglob/index.js", "node_modules/is-glob/index.js", "node_modules/glob-parent/index.js", "node_modules/braces/lib/utils.js", "node_modules/braces/lib/stringify.js", "node_modules/is-number/index.js", "node_modules/to-regex-range/index.js", "node_modules/fill-range/index.js", "node_modules/braces/lib/compile.js", "node_modules/braces/lib/expand.js", "node_modules/braces/lib/constants.js", "node_modules/braces/lib/parse.js", "node_modules/braces/index.js", "node_modules/binary-extensions/index.js", "node_modules/is-binary-path/index.js", "node_modules/chokidar/lib/constants.js", "node_modules/chokidar/lib/nodefs-handler.js", "node_modules/chokidar/lib/fsevents-handler.js", "node_modules/chokidar/index.js", "src/termstyle.ts", "src/util.js", "src/memoize.js", "src/screen.js", "src/chmod.ts", "src/cli.ts", "src/log.ts", "src/file.ts", "src/watch.js", "src/tsutil.js", "src/tslint.js", "src/run.ts", "src/tsapi.ts", "src/estrella.js"],
  "sourcesContent": ["!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?e(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],e):e(t.miniglob={})}(this,function(t){\"use strict\";const{readdirSync:e,statSync:r}=require(\"fs\"),n=(()=>{try{return require(\"path\").sep}catch(t){return\"/\"}})(),o=n.charCodeAt(0),s=\":\"==n?/\\:+/g:\"\\\\\"==n?/\\\\+/g:/\\/+/g,u=\"win32\"==process.platform;class c extends Error{constructor(){super(\"bad pattern\")}}const i=u?t=>{if(t.length<2)return 0;let e=t[0];return\":\"==t[1]&&(\"a\"<=e&&e<=\"z\"||\"A\"<=e&&e<=\"Z\")?2:0}:t=>0,l=u?(t,e)=>{const r=e(t);return\"\"==t?[0,\".\"]:r+1==t.length&&h(t,t.length-1)?[r+1,t]:r==t.length&&2==t.length?[r,t+\".\"]:(r>=t.length&&(r=t.length-1),[r,t.substr(0,t.length-1)])}:(t,e)=>\"\"==t?[e,\".\"]:t==n?[e,t]:[e,t.substr(0,t.length-1)];function h(t,e){return t.charCodeAt(e)===o}function f(t,u){t=function(t){let e=t.length-1,r=e;for(;r&&t.charCodeAt(r)===o;)--r;r!=e&&(t=t.substr(0,r+1));return t.split(s).join(n)}(t);let c=r(t);c.isDirectory()&&function t(r,n,o){for(let s of e(r)){let e=k(r,s),u=y(e),c=n(e,u);(c||void 0===c)&&u&&u.isDirectory()&&!o.has(u.ino)&&(o.add(u.ino),t(e,n,o))}}(t,u,new Set([c.ino]))}function a(t){let e=[];if(!g(t))return y(t)?[t]:e;let r=i(t),n=t.length-1;for(;n>=r&&!h(t,n);)n--;let o=t.substr(0,n+1),s=t.substr(n+1);if([r,o]=l(o,r),g(o.substr(r))){if(o==t)throw new c;const r=a(o);for(let t of r)d(t,s,e)}else d(o,s,e);return e}function d(t,r,n){const o=y(t);if(null===o)return;if(!o.isDirectory())return;let s;try{s=e(t)}catch(t){return}s.sort();for(let e of s)A(r,e)&&n.push(k(t,e))}function g(t){for(let e=0;e<t.length;++e)switch(t.charCodeAt(e)){case 42:case 63:case 91:case 123:return!0}return!1}function b(t,e){for(let r=0;r<t.length;++r)if(t.charCodeAt(r)===e)return!0;return!1}function A(t,e){t:for(;t.length>0;){let r=!1,n=\"\";if([r,n,t]=C(t),r&&\"\"==n)return!b(e,o);let[s,u]=w(n,e);if(!u||!(0==s.length||t.length>0)){if(r)for(let r=0;r<e.length&&e.charCodeAt(r)!=o;r++)if([s,u]=w(n,e.substr(r+1)),u){if(0==t.length&&s.length>0)continue;e=s;continue t}return!1}e=s}return 0==e.length}function C(t){let e=!1;for(;t.length>0&&42==t.charCodeAt(0);)t=t.substr(1),e=!0;let r=!1,n=0;t:for(;n<t.length;n++)switch(t.charCodeAt(n)){case 92:u||n+1<t.length&&n++;break;case 91:r=!0;break;case 93:r=!1;break;case 42:if(!r)break t}return[e,t.substr(0,n),t.substr(n)]}function w(t,e){for(;t.length>0;){if(0==e.length)return[\"\",!1];switch(t.charCodeAt(0)){case 91:{let r=e.codePointAt(0),n=r<=65535?1:2;if(e=e.substr(n),t=t.substr(1),r.toString(16),0==t.length)throw new c;let o=94==t.charCodeAt(0);o&&(t=t.substr(1));let s=!1,u=0;for(;;){if(t.length>0&&93==t.charCodeAt(0)&&u>0){t=t.substr(1);break}let e,n;if([n,t,e]=p(t),!e)return[\"\",!1];let o=n;if(45==t.charCodeAt(0)&&([o,t,e]=p(t.substr(1)),!e))return[\"\",!1];n<=r&&r<=o&&(s=!0),u++}if(s==o)return[\"\",!1];break}case 63:if(e.charCodeAt(0)==o)return[\"\",!1];let r=e.codePointAt(0)<=65535?1:2;e=e.substr(r),t=t.substr(1);break;case 92:if(!u&&0==(t=t.substr(1)).length)throw new c;default:if(t.charCodeAt(0)!=e.charCodeAt(0))return t[0],e[0],t.charCodeAt(0).toString(16),e.charCodeAt(0).toString(16),[\"\",!1];e=e.substr(1),t=t.substr(1)}}return[e,!0]}function p(t){let e=0,r=\"\",n=t.charCodeAt(0);if(0==t.length||45==n||93==n)throw new c;if(92==n&&!u&&0==(t=t.substr(1)).length)throw new c;let o=(e=t.codePointAt(0))<=65535?1:2;if(65535==e&&1==o)throw new c;if(0==(r=t.substr(o)).length)throw new c;return[e,r,!0]}function y(t){try{return r(t)}catch(t){}return null}function k(t,e){return\".\"==t||\"\"==t?e:t+n+e}t.PatternError=c,t.glob=function(t){if(t.indexOf(\"**\")<0)return a(t);let e=[],s=new Set;return function t(e,s,u,c,i){u>=s.length&&(u=s.length-1);let l=s[u],h=l;function d(t){return!i.has(t)&&(i.add(t),!0)}function g(t){let e=t,r=e.lastIndexOf(n);-1!=r&&(e=e.substr(r+1));let i=Math.min(u+1,s.length-1),l=s.slice(i).join(\"*\");l.charCodeAt(0)==o?l=function(t){let e=0;for(;t.charCodeAt(e)===o;)e++;return 0!=e?t.substr(e):t}(l):\"*\"!=l[0]&&(l=\"*\"+l),A(l,e)&&c.push(t)}0===u?l.charCodeAt(l.length-1)!=o&&(h+=\"*\"):u===s.length-1?l.charCodeAt(0)!=o&&(h=\"*\"+h):(l.charCodeAt(0)!=o&&(h=\"*\"+h),l.charCodeAt(l.length-1)!=o&&(h+=\"*\")),e&&(h=h[0]!=n?e+n+h:e+h);let b=!1;h.charCodeAt(h.length-1)===o&&(b=!0,h=function(t){let e=t.length-1,r=e;for(;t.charCodeAt(r)===o;)r--;return r!=e?t.substr(0,r+1):t}(h));let C=a(h);for(let e of C){let n=r(e);n.isDirectory()?d(e)&&f(e,(e,r)=>{d(e)&&(r.isDirectory()?t(e,s,u+1,c,i):g(e))}):!b&&d(e)&&g(e)}return c}(\"\",t.split(/\\*{2,}/),0,e,s),e},t.match=A,Object.defineProperty(t,\"__esModule\",{value:!0})});", "'use strict';\n\nconst path = require('path');\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n", "'use strict';\n\nconst path = require('path');\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n", "'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n      }\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n", "'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = (opts) => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index];\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.prev.type === 'bos' && eos()) {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance() || '';\n      } else {\n        value += advance() || '';\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = (opts) => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n", "'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return parsed.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${parsed.output})${append}`;\n  if (parsed && parsed.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = parsed;\n  }\n\n  return regex;\n};\n\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  const opts = options || {};\n  let parsed = { negated: false, fastpaths: true };\n  let prefix = '';\n  let output;\n\n  if (input.startsWith('./')) {\n    input = input.slice(2);\n    prefix = parsed.prefix = './';\n  }\n\n  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    output = parse.fastpaths(input, options);\n  }\n\n  if (output === undefined) {\n    parsed = parse(input, options);\n    parsed.prefix = prefix + (parsed.prefix || '');\n  } else {\n    parsed.output = output;\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n", "'use strict';\n\nmodule.exports = require('./lib/picomatch');\n", "'use strict';\n\nconst fs = require('fs');\nconst { Readable } = require('stream');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat : stat;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (process.platform === 'win32' && stat.length === 3) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return {files, depth, path};\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\n      entry = {path: sysPath.relative(this._root, fullPath), fullPath, basename};\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      try {\n        const entryRealPath = await realpath(entry.fullPath);\n        const entryRealPathStats = await lstat(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\n\nmodule.exports = readdirp;\n", "/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nmodule.exports = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nconst picomatch = require('picomatch');\nconst normalizePath = require('normalize-path');\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath(_path);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers.map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;\n", "/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n", "/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = require('is-extglob');\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictRegex = /\\\\(.)|(^!|\\*|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\nvar relaxedRegex = /\\\\(.)|(^!|[*?{}()[\\]]|\\(\\?)/;\n\nmodule.exports = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var regex = strictRegex;\n  var match;\n\n  // optionally relax regex\n  if (options && options.strict === false) {\n    regex = relaxedRegex;\n  }\n\n  while ((match = regex.exec(str))) {\n    if (match[2]) return true;\n    var idx = match.index + match[0].length;\n\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    var open = match[1];\n    var close = open ? chars[open] : null;\n    if (open && close) {\n      var n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n\n    str = str.slice(idx);\n  }\n  return false;\n};\n", "'use strict';\n\nvar isGlob = require('is-glob');\nvar pathPosixDirname = require('path').posix.dirname;\nvar isWin32 = require('os').platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\/]*.*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n */\nmodule.exports = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n", "'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  let node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n    return result;\n  };\n  flat(args);\n  return result;\n};\n", "'use strict';\n\nconst utils = require('./utils');\n\nmodule.exports = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n", "/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n", "/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isNumber = require('is-number');\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n", "/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nconst util = require('util');\nconst toRegexRange = require('to-regex-range');\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;\n", "'use strict';\n\nconst fill = require('fill-range');\nconst utils = require('./utils');\n\nconst compile = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      let range = fill(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nmodule.exports = compile;\n", "'use strict';\n\nconst fill = require('fill-range');\nconst stringify = require('./stringify');\nconst utils = require('./utils');\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nmodule.exports = expand;\n", "'use strict';\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n", "'use strict';\n\nconst stringify = require('./stringify');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = require('./constants');\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  let memo = {};\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n\n      let closed = true;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nmodule.exports = parse;\n", "'use strict';\n\nconst stringify = require('./lib/stringify');\nconst compile = require('./lib/compile');\nconst expand = require('./lib/expand');\nconst parse = require('./lib/parse');\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces.compile(input, options)\n    : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nmodule.exports = braces;\n", "module.exports = require('./binary-extensions.json');\n", "'use strict';\nconst path = require('path');\nconst binaryExtensions = require('binary-extensions');\n\nconst extensions = new Set(binaryExtensions);\n\nmodule.exports = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n", "'use strict';\n\nconst {sep} = require('path');\nconst {platform} = process;\n\nexports.EV_ALL = 'all';\nexports.EV_READY = 'ready';\nexports.EV_ADD = 'add';\nexports.EV_CHANGE = 'change';\nexports.EV_ADD_DIR = 'addDir';\nexports.EV_UNLINK = 'unlink';\nexports.EV_UNLINK_DIR = 'unlinkDir';\nexports.EV_RAW = 'raw';\nexports.EV_ERROR = 'error';\n\nexports.STR_DATA = 'data';\nexports.STR_END = 'end';\nexports.STR_CLOSE = 'close';\n\nexports.FSEVENT_CREATED = 'created';\nexports.FSEVENT_MODIFIED = 'modified';\nexports.FSEVENT_DELETED = 'deleted';\nexports.FSEVENT_MOVED = 'moved';\nexports.FSEVENT_CLONED = 'cloned';\nexports.FSEVENT_UNKNOWN = 'unknown';\nexports.FSEVENT_TYPE_FILE = 'file';\nexports.FSEVENT_TYPE_DIRECTORY = 'directory';\nexports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\nexports.KEY_LISTENERS = 'listeners';\nexports.KEY_ERR = 'errHandlers';\nexports.KEY_RAW = 'rawEmitters';\nexports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\nexports.DOT_SLASH = `.${sep}`;\n\nexports.BACK_SLASH_RE = /\\\\/g;\nexports.DOUBLE_SLASH_RE = /\\/\\//;\nexports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\nexports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\nexports.REPLACER_RE = /^\\.[/\\\\]/;\n\nexports.SLASH = '/';\nexports.SLASH_SLASH = '//';\nexports.BRACE_START = '{';\nexports.BANG = '!';\nexports.ONE_DOT = '.';\nexports.TWO_DOTS = '..';\nexports.STAR = '*';\nexports.GLOBSTAR = '**';\nexports.ROOT_GLOBSTAR = '/**/*';\nexports.SLASH_GLOBSTAR = '/**';\nexports.DIR_SUFFIX = 'Dir';\nexports.ANYMATCH_OPTS = {dot: true};\nexports.STRING_TYPE = 'string';\nexports.FUNCTION_TYPE = 'function';\nexports.EMPTY_STR = '';\nexports.EMPTY_FN = () => {};\nexports.IDENTITY_FN = val => val;\n\nexports.isWindows = platform === 'win32';\nexports.isMacos = platform === 'darwin';\nexports.isLinux = platform === 'linux';\n", "'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst isBinaryPath = require('is-binary-path');\nconst {\n  isWindows,\n  isLinux,\n  EMPTY_FN,\n  EMPTY_STR,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE,\n  EV_ADD,\n  EV_ADD_DIR,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  BRACE_START,\n  STAR\n} = require('./constants');\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify(fs.open);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst close = promisify(fs.close);\nconst fsrealpath = promisify(fs.realpath);\n\nconst statMethods = { lstat, stat };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  /* eslint-disable no-unused-vars, prefer-destructuring */\n  let listeners = new Set();\n  let rawEmitters = new Set();\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = cont.listeners;\n    rawEmitters = cont.rawEmitters;\n    fs.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nclass NodeFsHandler {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path, listener) {\n  const opts = this.fsw.options;\n  const directory = sysPath.dirname(path);\n  const basename = sysPath.basename(path);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = sysPath.resolve(path);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = sysPath.dirname(file);\n  const basename = sysPath.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  const listener = async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE, file, newStats);\n        }\n        if (isLinux && prevStats.ino !== newStats.ino) {\n          this.fsw._closeFile(path)\n          prevStats = newStats;\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n        } else {\n          prevStats = newStats;\n        }\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n      // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  }\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, listener);\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n    this.fsw._emit(EV_ADD, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n    const linkPath = await fsrealpath(path);\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = sysPath.join(directory, EMPTY_STR);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path = sysPath.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path = sysPath.join(dir, sysPath.relative(dir, path));\n\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n  const tracked = parentDir.has(sysPath.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\n    let closer;\n    if (stats.isDirectory()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (path !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(targetPath, true);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      const parent = sysPath.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path;\n    }\n  }\n}\n\n}\n\nmodule.exports = NodeFsHandler;\n", "'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\n\nlet fsevents;\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD,\n  EV_CHANGE,\n  EV_ADD_DIR,\n  EV_UNLINK,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE,\n  EMPTY_FN,\n  IDENTITY_FN\n} = require('./constants');\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\nconst statMethods = { stat, lstat };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\n  const parentPath = sysPath.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n)\n\n/**\n * @mixin\n */\nclass FsEventsHandler {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat(path)\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed) return;\n  if (this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path = transform(sysPath.join(\n      watchPath, sysPath.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    const parent = sysPath.dirname(path);\n    const item = sysPath.basename(path);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE) {\n        let stats;\n        try {\n          stats = await stat(path);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== DOT_SLASH) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n  const base = sysPath.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n  }\n}\n\ninitWatch(realPath, path, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    sysPath.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = sysPath.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path, wh, processPath);\n    }\n  }\n}\n\n}\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;\n", "'use strict';\n\nconst { EventEmitter } = require('events');\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst readdirp = require('readdirp');\nconst anymatch = require('anymatch').default;\nconst globParent = require('glob-parent');\nconst isGlob = require('is-glob');\nconst braces = require('braces');\nconst normalizePath = require('normalize-path');\n\nconst NodeFsHandler = require('./lib/nodefs-handler');\nconst FsEventsHandler = require('./lib/fsevents-handler');\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos\n} = require('./lib/constants');\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // You\u2019re frozen when your heart\u2019s not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path)\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nexports.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;\n", "import {\n  TermStyle as TermStyleAPI,\n  TermStyleFun,\n  TTYStream,\n  NoTTYStream,\n} from \"../estrella\"\n\n\nexport interface TermStyle extends TermStyleAPI {\n  _hint :boolean|undefined  // original hint\n\n  // Like calling termStyle but instead of returning a new TermStyle object,\n  // the receiver (this) is updated/mutated.\n  reconfigure(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle\n}\n\n\nfunction numColors(w :TTYStream|NoTTYStream, hint? :boolean) {\n  let ncolors = 0\n  if (hint === true) {\n    // use colors regardless of TTY or not\n    let t = process.env.TERM || \"\"\n    ncolors = (\n      t && ['xterm','screen','vt100'].some(s => t.indexOf(s) != -1) ? (\n        t.indexOf('256color') != -1 ? 8 : 4\n      ) : 2\n    )\n  } else if (hint !== false && w.isTTY) {\n    // unless hint is explicitly false, use colors if stdout is a TTY\n    ncolors = w.getColorDepth()\n  }\n  return ncolors\n}\n\ntype TermStyleFunCons = (open16 :string, open256 :string, close :string) => TermStyleFun\n\n\nexport function termStyle(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle {\n  return createTermStyle(numColors(w, hint), hint)\n}\n\n\nexport function createTermStyle(ncolors :number, hint? :boolean) :TermStyle {\n  const CODE = (s :string) => `\\x1b[${s}m`\n\n  const effect :(open :string, close :string)=>TermStyleFun = (\n    ncolors > 0 || hint ? (open, close) => {\n      const a = CODE(open), b = CODE(close)\n      return s => a + s + b\n    } :\n    (_) => s => s\n  )\n\n  const color :TermStyleFunCons = (\n\n    // 256 colors support\n    ncolors >= 8 ? (_open16, open256, close) => {\n      // const open = CODE(code), close = CODE('2' + code)\n      let a = '\\x1b[' + open256 + 'm', b = '\\x1b[' + close + 'm'\n      return s => a + s + b\n    } :\n\n    // 16 colors support\n    ncolors > 0 ? (open16, _open256, close) => {\n      let a = '\\x1b[' + open16 + 'm', b = '\\x1b[' + close + 'm'\n      return s => a + s + b\n    } :\n\n    // no colors\n    (_open16, _open256, _close) => s => s\n  )\n\n  return {\n    _hint: hint,\n    ncolors,\n\n    reset     : hint || ncolors > 0 ? \"\\e[0m\" : \"\",\n\n    bold      : effect('1', '22'),\n    italic    : effect('3', '23'),\n    underline : effect('4', '24'),\n    inverse   : effect('7', '27'),\n\n    // name           16c    256c                 close\n    white       : color('37',  '38;2;255;255;255',  '39'),\n    grey        : color('90',  '38;5;244',          '39'),\n    black       : color('30',  '38;5;16',           '39'),\n    blue        : color('34',  '38;5;75',           '39'),\n    cyan        : color('36',  '38;5;87',           '39'),\n    green       : color('32',  '38;5;84',           '39'),\n    magenta     : color('35',  '38;5;213',          '39'),\n    purple      : color('35',  '38;5;141',          '39'),\n    pink        : color('35',  '38;5;211',          '39'),\n    red         : color('31',  '38;2;255;110;80',   '39'),\n    yellow      : color('33',  '38;5;227',          '39'),\n    lightyellow : color('93',  '38;5;229',          '39'),\n    orange      : color('33',  '38;5;215',          '39'),\n\n    reconfigure(w :TTYStream|NoTTYStream, hint? :boolean) :TermStyle {\n      const ncolors = numColors(w, hint)\n      if (ncolors != this.ncolors && hint != this._hint) {\n        Object.assign(this, createTermStyle(ncolors, hint))\n      }\n      return this\n    },\n\n  }\n}\n\nexport const stdoutStyle = termStyle(process.stdout)\nexport const stderrStyle = termStyle(process.stderr)\n", "import * as fs from \"fs\"\nimport * as Path from \"path\"\nimport { performance } from \"perf_hooks\"\nimport { stdoutStyle } from \"./termstyle\"\nimport { inspect } from \"util\"\n\nexport const json = (val, pretty, showHidden) => JSON.stringify(val, showHidden, pretty)\nexport const clock = () => performance.now()\n\nexport function repr(val, prettyOrOptions) {\n  let options = { colors: stdoutStyle.ncolors > 0 }\n  if (typeof prettyOrOptions == \"object\") {\n    options = { ...prettyOrOptions }\n  } else if (prettyOrOptions !== undefined) {\n    options.compact = !prettyOrOptions\n  }\n  return inspect(val, options)\n}\n\n\nexport function fmtDuration(ms) {\n  return (\n    ms >= 59500 ? (ms/60000).toFixed(0) + \"min\" :\n    ms >= 999.5 ? (ms/1000).toFixed(1) + \"s\" :\n    ms.toFixed(2) + \"ms\"\n  )\n}\n\nexport function fmtByteSize(bytes) {\n  return (\n    bytes >= 1024*1000 ? (bytes/(1024*1000)).toFixed(1) + \"MB\" :\n    bytes >= 1000 ? (bytes/1024).toFixed(1) + \"kB\" :\n    bytes + \"B\"\n  )\n}\n\nexport function findInPATH(executableName) {\n  const testExeExtToo = process.platform.startsWith(\"win\") && !/\\.exe$/i.test(executableName)\n  for (let dir of (process.env.PATH || \"\").split(Path.delimiter)) {\n    let path = Path.join(Path.resolve(dir), executableName)\n    while (true) {\n      try {\n        let st = fs.statSync(path)\n        if (st.isSymbolicLink()) {\n          path = fs.realpathSync.native(path)\n          continue\n        } else if (st.isFile() && st.mode & fs.constants.X_OK) {\n          return path\n        }\n      } catch (_) {}\n      break\n    }\n  }\n  return null\n}\n\n\n// jsonparse parses \"relaxed\" JSON which can be in JavaScript format\nexport function jsonparse(jsonText, filename /*optional*/) {\n  const vm = require(\"vm\")\n  return vm.runInNewContext(\n    '(' + jsonText + ')',\n    { /* sandbox */ },\n    { filename, displayErrors: true }\n  )\n}\n\nexport function jsonparseFile(filename) {\n  return jsonparse(fs.readFileSync(filename, \"utf8\"), filename)\n}\n\n\nlet homedir = null\n\nexport function tildePath(path) {\n  const s = Path.resolve(path)\n  if (!homedir) { homedir = require(\"os\").homedir() }\n  if (s.startsWith(homedir)) {\n    return \"~\" + s.substr(homedir.length)\n  }\n  return s\n}\n", "import { json } from \"./util\"\n\nconst memoizeMap = new Map()\n\nexport const isMemoized = Symbol(\"isMemoized\")\n\nexport function memoize(fn) {\n  return function memoizedCall(...args) {\n    let k = args.map(json).join(\"\\0\")\n    if (!memoizeMap.has(k)) {\n      const result = fn(...args)\n      memoizeMap.set(k, result)\n      return result\n    }\n    let v = memoizeMap.get(k)\n    if (v && typeof v == \"object\") {\n      v[isMemoized] = true\n    }\n    return v\n  }\n}\n", "const stdoutIsTTY = !!process.stdout.isTTY\n    , stderrIsTTY = !!process.stderr.isTTY\n\nexport const screen = {\n  width: 60,\n  height: 20,\n  clear() {},\n  banner(ch) {\n    if (!ch) { ch = \"-\" }\n    return ch.repeat(Math.floor((screen.width - 1) / ch.length))\n  },\n}\n\nif (stdoutIsTTY || stderrIsTTY) {\n  const ws = (stdoutIsTTY && process.stdout) || process.stderr\n  const updateScreenSize = () => {\n    screen.width = ws.columns\n    screen.height = ws.rows\n  }\n  ws.on(\"resize\", updateScreenSize)\n  updateScreenSize()\n  screen.clear = () => {\n    // Note: \\ec is reported to not work on the KDE console Konsole.\n    // TODO: detect KDE Konsole and use \\e[2J instead\n    // Clear display: \"\\x1bc\"\n    // Clear Screen: \\x1b[{n}J clears the screen\n    //   n=0 clears from cursor until end of screen\n    //   n=1 clears from cursor to beginning of screen\n    //   n=2 clears entire screen\n    ws.write(\"\\x1bc\")\n  }\n  // Note: we can clear past rows relatively using these two functions:\n  // ws.moveCursor(0, -4)\n  // ws.clearScreenDown()\n}\n", "import * as fs from \"fs\"\nimport { json } from \"./util\"\n\nconst chr = String.fromCharCode\nconst ord = (s :string, offs :number) => s.charCodeAt(offs || 0)\n\n\nexport type Modifier = number\n                     | string\n                     | string[]\n\n// chmod edits mode of a file (synchronous)\n// If m is a number, the mode is simply set to m.\n// If m is a string or list of strings, the mode is updated using editFileMode.\n// Returns the new mode set on file.\nexport function chmod(file :fs.PathLike, modifier :Modifier) :number {\n  if (typeof modifier == \"number\") {\n    fs.chmodSync(file, modifier)\n    return modifier\n  }\n  let mode = fs.statSync(file).mode\n  let newMode = editFileMode(mode, modifier)\n  if (mode != newMode) {\n    fs.chmodSync(file, newMode)\n  }\n  return newMode\n}\n\n// async version of chmod\nexport function chmodp(file :fs.PathLike, modifier :Modifier) :Promise<number> {\n  return new Promise<number>((resolve, reject) => {\n    if (typeof modifier == \"number\") {\n      return fs.chmod(file, modifier, err => {\n        err ? reject(err) : resolve(modifier)\n      })\n    }\n    fs.stat(file, (err, st) => {\n      if (err) return reject(err)\n      let newMode = editFileMode(st.mode, modifier)\n      if (st.mode == newMode) {\n        return resolve(newMode)\n      }\n      fs.chmod(file, newMode, err => {\n        err ? reject(err) : resolve(newMode)\n      })\n    })\n  })\n}\n\n\n// editFileMode takes a file mode (e.g. 0o764), applies modifiers and returns the resulting mode.\n// It accepts the same format as the Posix chmod program.\n// If multiple modifiers are provided, they are applied to mode in order.\n//\n// Grammar of modifier format:\n//\n//   mode   := clause [, clause ...]\n//   clause := [who ...] [action ...] action\n//   action := op [perm ...]\n//   who    := a | u | g | o\n//   op     := + | - | =\n//   perm   := r | w | x\n//\n// Examples:\n//\n//   // Set execute bit for user and group\n//   newMode = editFileMode(0o444, \"ug+x\") // => 0o554\n//\n//   // Set execute bit for user, write bit for group and remove all access for others\n//   newMode = editFileMode(0o444, \"+x,g+w,o-\") // => 0o560\n//\nexport function editFileMode(mode :number, modifier :string|string[]) :number {\n  const expectedFormat = `Expected format: [ugoa]*[+-=][rwx]+`\n\n  const err = (msg :string, m :any) =>\n    new Error(`${msg} in modifier ${json(m)}. ${expectedFormat}`)\n\n  let mods :string[] = []\n  for (let m of Array.isArray(modifier) ? modifier : [ modifier ]) {\n    mods = mods.concat(m.trim().split(/\\s*,+\\s*/))\n  }\n\n  for (let m of mods) {\n    let who :number[] = []\n    let all = false\n    let op = 0\n    let perm = 0\n\n    for (let i = 0; i < m.length; i++) {\n      let c = ord(m, i)\n      if (op == 0) {\n        switch (c) {\n          case 0x75: // u\n          case 0x67: // g\n          case 0x6F: // o\n            if (!all) {\n              who.push(c)\n            }\n            break\n          case 0x61: // a\n            who = [ 0x75, 0x67, 0x6F ]\n            all = true\n            break\n          case 0x2B: // +\n          case 0x2D: // -\n          case 0x3D: // =\n            op = c\n            break\n          default:\n            if (op == 0) {\n              throw err(`Invalid target or operation ${json(chr(c))}`, m)\n            }\n            break\n        }\n      } else {\n        switch (c) {\n          case 0x72: perm |= 0o4 ; break // r\n          case 0x77: perm |= 0o2 ; break // w\n          case 0x78: perm |= 0o1 ; break // x\n          default: throw err(`Invalid permission ${json(chr(c))}`, m)\n        }\n      }\n    }\n    if (op == 0) {\n      throw err(`Missing operation`, m)\n    }\n    if (who.length == 0) {\n      who = [ 0x75 ] // u\n    }\n    if (perm == 0) {\n      perm = 0o4 | 0o2 | 0o1\n    }\n\n    let mode2 = 0\n    for (let w of who) {\n      switch (w) {\n        case 0x75: mode2 |= (perm << 6) ; break  // u\n        case 0x67: mode2 |= (perm << 3) ; break  // g\n        case 0x6F: mode2 |= perm        ; break  // o\n      }\n    }\n    switch (op) {\n      case 0x2B: mode |= mode2 ; break  // +\n      case 0x2D: mode &= ~mode2 ; break // -\n      case 0x3D: mode = mode2 ; break   // =\n    }\n    // For debugging:\n    // console.log({\n    //   who: who.map(n => '0o' + n.toString(8)),\n    //   op: String.fromCharCode(op),\n    //   perm: '0o' + perm.toString(8),\n    // })\n  } // for each m in modifier\n  return mode\n}\n\n\ndeclare const DEBUG :boolean\n\n// lil' unit test for editFileMode\nif (DEBUG) {\n  const asserteq = require(\"assert\").strictEqual\n  const oct = (v :number) => \"0o\" + v.toString(8).padStart(3, '0')\n  //  input, modifiers, expected\n  const samples :\n    [ number, string[], number ][] = [\n    [ 0o444, [\"u+r\"],   0o444 ],\n    [ 0o444, [\"u+x\"],   0o544 ],\n    [ 0o444, [\"u+w\"],   0o644 ],\n    [ 0o444, [\"u+wx\"],  0o744 ],\n    [ 0o444, [\"u+rwx\"], 0o744 ],\n    [ 0o444, [\"u+r,u+w,u+x\"],    0o744 ],\n    [ 0o444, [\"u+r\", \"u+w,u+x\"], 0o744 ],\n    [ 0o444, [\"u+\"],    0o744 ], // no perm spec = all\n\n    [ 0o777, [\"u-r\"],   0o377 ],\n    [ 0o777, [\"u-wx\"],  0o477 ],\n    [ 0o777, [\"u-w\"],   0o577 ],\n    [ 0o777, [\"u-x\"],   0o677 ],\n    [ 0o777, [\"u-\"],    0o077 ],\n    [ 0o777, [\"u-rwx\"], 0o077 ],\n\n    [ 0o444, [\"g+r\"],   0o444 ],\n    [ 0o444, [\"g+x\"],   0o454 ],\n    [ 0o444, [\"g+w\"],   0o464 ],\n    [ 0o444, [\"g+wx\"],  0o474 ],\n    [ 0o444, [\"g+rwx\"], 0o474 ],\n    [ 0o444, [\"g+\"],    0o474 ],\n\n    [ 0o777, [\"g-r\"],   0o737 ],\n    [ 0o777, [\"g-wx\"],  0o747 ],\n    [ 0o777, [\"g-w\"],   0o757 ],\n    [ 0o777, [\"g-x\"],   0o767 ],\n    [ 0o777, [\"g-\"],    0o707 ],\n    [ 0o777, [\"g-rwx\"], 0o707 ],\n\n    [ 0o444, [\"o+r\"],   0o444 ],\n    [ 0o444, [\"o+x\"],   0o445 ],\n    [ 0o444, [\"o+w\"],   0o446 ],\n    [ 0o444, [\"o+wx\"],  0o447 ],\n    [ 0o444, [\"o+rwx\"], 0o447 ],\n    [ 0o444, [\"o+\"],    0o447 ],\n\n    [ 0o777, [\"o-r\"],   0o773 ],\n    [ 0o777, [\"o-wx\"],  0o774 ],\n    [ 0o777, [\"o-w\"],   0o775 ],\n    [ 0o777, [\"o-x\"],   0o776 ],\n    [ 0o777, [\"o-\"],    0o770 ],\n    [ 0o777, [\"o-rwx\"], 0o770 ],\n\n\n    [ 0o444, [\"ug+r\"],   0o444 ],\n    [ 0o444, [\"ug+x\"],   0o554 ],\n    [ 0o444, [\"ug+w\"],   0o664 ],\n    [ 0o444, [\"ug+wx\"],  0o774 ],\n    [ 0o444, [\"ug+rwx\"], 0o774 ],\n    [ 0o444, [\"ug+\"],    0o774 ],\n\n    [ 0o444, [\"ugo+r\"],   0o444 ],  [ 0o444, [\"a+r\"],   0o444 ],\n    [ 0o444, [\"ugo+x\"],   0o555 ],  [ 0o444, [\"a+x\"],   0o555 ],\n    [ 0o444, [\"ugo+w\"],   0o666 ],  [ 0o444, [\"a+w\"],   0o666 ],\n    [ 0o444, [\"ugo+wx\"],  0o777 ],  [ 0o444, [\"a+wx\"],  0o777 ],\n    [ 0o444, [\"ugo+rwx\"], 0o777 ],  [ 0o444, [\"a+rwx\"], 0o777 ],\n    [ 0o444, [\"ugo+\"],    0o777 ],  [ 0o444, [\"a+\"],    0o777 ],\n\n    [ 0o777, [\"ug-r\"],   0o337 ],\n    [ 0o777, [\"ug-wx\"],  0o447 ],\n    [ 0o777, [\"ug-w\"],   0o557 ],\n    [ 0o777, [\"ug-x\"],   0o667 ],\n    [ 0o777, [\"ug-\"],    0o007 ],\n    [ 0o777, [\"ug-rwx\"], 0o007 ],\n\n    [ 0o777, [\"ugo-r\"],   0o333 ],  [ 0o777, [\"a-r\"],   0o333 ],\n    [ 0o777, [\"ugo-wx\"],  0o444 ],  [ 0o777, [\"a-wx\"],  0o444 ],\n    [ 0o777, [\"ugo-w\"],   0o555 ],  [ 0o777, [\"a-w\"],   0o555 ],\n    [ 0o777, [\"ugo-x\"],   0o666 ],  [ 0o777, [\"a-x\"],   0o666 ],\n    [ 0o777, [\"ugo-\"],    0o000 ],  [ 0o777, [\"a-\"],    0o000 ],\n    [ 0o777, [\"ugo-rwx\"], 0o000 ],  [ 0o777, [\"a-rwx\"], 0o000 ],\n  ] // samples\n\n  samples.map(([input, mods, expect]) => {\n    let actual = editFileMode(input, mods)\n    asserteq(actual, expect,\n      `editFileMode(${oct(input)}, ${json(mods)}) => ` +\n      `${oct(actual)} != expected ${oct(expect)}`\n    )\n  })\n} // end of editFileMode tests\n", "import * as Path from \"path\"\nimport { json } from \"./util\"\n\n\n// parse CLI program name (as invoked)\nexport const prog = (() :string => {\n  const $_ = process.env[\"_\"]\n  const scriptfile = process.argv[1]\n  if (!scriptfile) {\n    // unlikely\n    return $_ || process.argv[0]\n  }\n  if ($_ && !Path.isAbsolute($_)) {\n    // accurate in some shells (like bash, but not in zsh)\n    return $_\n  }\n  let prefix = \"\"\n  if ($_) {\n    const nodeExecName = Path.basename(process.execPath)\n    if ($_.endsWith(Path.sep + nodeExecName)) {\n      // the script was invoked by explicitly calling node.\n      // e.g. \"node build.js\"\n      prefix = nodeExecName + \" \"\n    }\n  }\n  if (scriptfile.startsWith(process.cwd())) {\n    let rel = Path.relative(process.cwd(), scriptfile)\n    if (!rel.startsWith(\"node_modules\"+Path.sep) &&\n        rel.indexOf(Path.sep+\"node_modules\"+Path.sep) == -1\n    ) {\n      if (Path.sep == \"/\") {\n        // on posix systems, this is needed to avoid PATH resolution\n        rel = \"./\" + rel\n      }\n      return rel\n    }\n  }\n  return prefix + Path.basename(scriptfile)\n})()\n\n\nexport function printUsageAndExit(usage :string, errmsg? :string|null) {\n  const msg = usage.trim().replace(/\\$0\\b/g, prog)\n  if (errmsg) {\n    console.error(`${prog}: ${errmsg}\\n` + msg)\n    process.exit(1)\n  } else {\n    console.log(msg)\n    process.exit(0)\n  }\n}\n\n// parseopt types\nexport interface Doc {\n  usage?   :Usage|null\n  flags    :Flags[]\n  trailer? :string\n\n  // if true, treat an unknown flag as an argument (no error)\n  unknownFlagAsArg? :boolean\n\n  // help is a function which is invoked INSTEAD OF printing help and exiting the process.\n  // The function receives three values:\n  //   flags   -- available flags\n  //   options -- flag values parsed so far\n  //   args    -- remaining, unprocessed input arguments\n  // options and args are the same values returned by parseopt()\n  //\n  help? :( (flags: FlagInfo[], options :Options, args :string[]) => void ) | null\n}\nexport type Usage = string | (()=>string)\nexport type Flags = (Flag | null | undefined | false)[]  // falsy elements are ignored\nexport type Flag  = string | [ string|string[] , string?, string? ]\nexport interface FlagInfo {\n  names        :string[]\n  description? :string\n  valueName?   :string\n  valueType?   :string\n  valueParser? :(v:string)=>any\n}\nexport type Options = { [k :string] :any }\n\n// parseopt parses command-line arguments.\n// Returns options and unparsed remaining arguments.\n//\n// flag format:\n//\n//   flag      = flagname | flagspec\n//   flagname  = \"-\"* <text>\n//   flagnames = Array< flagname+ >\n//   flagspec  = Tuple< flagnames | flagname >\n//\n// flag format examples:\n//\n//   \"verbose\"\n//   Simple boolean flag that can be set with -verbose or --verbose.\n//\n//   [ \"v\", \"Show version\" ]\n//   Boolean flag \"v\" with description text shown in program usage.\n//\n//   [ \"v, version\", \"Show version\" ]\n//   [ [\"v\", \"version\"], \"Show version\" ]\n//   Boolean flag \"v\" with alternate name \"version\" with description.\n//\n//   [ [\"v\", \"version\"] ]\n//   Boolean flag \"v\" with alternate name \"version\" without description.\n//\n//   [ \"o\", \"Output file\", \"<path>\" ]\n//   Value flag with description. Value type defaults to string.\n//   Can be invoked as -o=path, --o=path, -o path, and --o path.\n//\n//   [ \"o\", \"\", \"<path>\" ]\n//   Value flag without description.\n//\n//   [ \"limit\", \"Show no more than <limit> items\", \"<limit:number>\" ]\n//   Value flag with type constraint. Passing a value that is not a JS number\n//   causes an error message.\n//\n//   [ \"with-openssl\", \"\", \"enable:bool\" ]\n//   Boolean flag\n//\nexport function parseopt(argv :string[], doc :Doc) :[Options, string[]] {\n  let [flagmap, opts] = parseFlags(doc.flags.filter(f => f) as Flag[])\n  let options :Options = {}\n  let help = false\n  let args :string[] = []\n  let i = 0\n\n  const eatArg = () => {\n    args.push(argv.splice(i, 1)[0])\n    i--\n  }\n\n  for (; i < argv.length; i++) {\n    // read argument\n    let arg = argv[i]\n    if (arg == '--') {\n      i++\n      break\n    }\n    if (arg[0] != '-') {\n      eatArg()\n      continue\n    }\n    arg = arg.replace(/^\\-+/, '')\n    let eqp = arg.indexOf('=')\n    let argval :string|undefined = undefined\n    if (eqp != -1) {\n      // e.g. -name=value\n      argval = arg.substr(eqp + 1)\n      arg = arg.substr(0, eqp)\n    }\n\n    // lookup flag\n    let opt = flagmap.get(arg)\n    if (!opt) {\n      if (arg == \"h\" || arg == \"help\") {\n        help = true\n        if (!doc.help) {\n          console.log(fmtUsage(opts, doc.usage, doc.trailer))\n          process.exit(0)\n        }\n      } else if (doc.unknownFlagAsArg) {\n        eatArg()\n        continue\n      } else {\n        console.error(`unknown option -${arg} (see ${prog} -help)`)\n        process.exit(1)\n      }\n      break\n    }\n\n    // save option\n    let value :any = true\n    if (opt.valueName) {\n      if (argval === undefined) {\n        // -k v\n        argval = argv[i + 1]\n        if (argval !== undefined && argval[0] != \"-\") {\n          i++\n        // } else if (opt.valueType == \"boolean\") {\n        //   argval = \"true\"\n        } else {\n          console.error(`missing value for option -${arg} (see ${prog} -help)`)\n          process.exit(1)\n          break\n        }\n      } // else -k=v\n      try {\n        value = opt.valueParser ? opt.valueParser(argval) : argval\n      } catch (err) {\n        console.error(`invalid value for option -${arg} (${err.message})`)\n      }\n    } else if (argval !== undefined) {\n      console.error(`unexpected value provided for flag -${arg}`)\n      process.exit(1)\n    } // else: e.g. -k\n\n    options[arg] = value\n\n    // alias spread\n    for (let alias of opt.names) {\n      if (alias == arg) {\n        continue\n      }\n      options[alias] = value\n    }\n\n  } // for (; i < argv.length; i++)\n\n  if (i < argv.length) {\n    args = args.concat(argv.slice(i))\n  }\n\n  if (help && doc.help) {\n    doc.help(opts, options, args)\n  }\n\n  return [options, args]\n}\n\n\n// parseFlags parses falgs and returns normalized structured options.\n// Returns:\n//   [0] Mapping of argument name (e.g. \"help\") to options.\n//   [1] Unique set of options (e.g. {flags:[\"h\",\"help\"],...}).\n//\nexport function parseFlags(flags :Flag[]) :[ Map<string,FlagInfo>, FlagInfo[] ] {\n  let fimap = new Map<string,FlagInfo>()\n  let fiv :FlagInfo[] = []\n  for (let f of flags) {\n    let fi = parseFlag(f)\n    fiv.push(fi)\n    for (let k of fi.names) {\n      if (fimap.has(k)) {\n        throw new Error(`duplicate CLI flag ${json(k)} in definition ${json(f)}`)\n      }\n      fimap.set(k, fi)\n    }\n  }\n  return [fimap, fiv]\n}\n\n\nfunction parseFlag(f :Flag) :FlagInfo {\n  const cleanFlag = (s :string) => s.replace(/(?:^|[\\s,])\\-+/g, '')\n  const splitComma = (s :string) => s.split(/\\s*,\\s*/)\n\n  if (typeof f == \"string\") {\n    return { names: splitComma(cleanFlag(f)) }\n  }\n\n  let o :FlagInfo = {\n    names: (\n      typeof f[0] == \"string\" ? splitComma(cleanFlag(f[0])) :\n      f[0].map(cleanFlag)\n    ),\n    description: f[1] || undefined\n  }\n\n  if (f[2]) {\n    let [name, type] = f[2].replace(/^[<>]+|[<>]+$/g, '').split(/:/, 2)\n    if (type) {\n      switch (type.toLowerCase()) {\n\n        case 'string':\n        case 'str':\n          type = 'string'\n          break\n\n        case 'bool':\n        case 'boolean':\n          type = 'boolean'\n          o.valueParser = s => {\n            s = s.toLowerCase()\n            return s != \"false\" && s != \"0\" && s != \"no\" && s != \"off\"\n          }\n          break\n\n        case 'number':\n        case 'num':\n        case 'float':\n        case 'int':\n          type = 'number'\n          o.valueParser = s => {\n            let n = Number(s)\n            if (isNaN(n)) {\n              throw new Error(`${json(s)} is not a number`)\n            }\n            return n\n          }\n          break\n\n        default:\n          throw new Error(`invalid argument type \"${type}\"`)\n      }\n    } else {\n      type = \"string\"\n    }\n    o.valueName = name || type\n    o.valueType = type\n  }\n  return o\n}\n\n\nexport function fmtUsage(opts :FlagInfo[], usage? :Usage|null, trailer? :string) :string {\n  // s/$name/value/\n  let vars :{[k:string]:any} = {\n    prog: prog,\n    \"0\": prog,\n  }\n  const subvars = (s :string) :string => s.replace(/\\$(\\w+)/g, (_, v) => {\n    let sub = vars[v]\n    if (!sub) {\n      throw new Error(`unknown variable $${v} (to print a dollar sign, use '\\\\$')`)\n    }\n    return sub\n  })\n\n  // start with usage\n  let s = subvars(\n    usage ?\n      typeof usage == 'function' ? usage() :\n                                   String(usage) :\n    opts.length > 0 ?\n      `Usage: $prog [options]` :\n      `Usage: $prog`\n  )\n\n  if (opts.length > 0) {\n    s += '\\noptions:\\n'\n    let longestFlagName = 0\n    let flagNames :string[] = []\n\n    for (let f of opts) {\n      let flagName = \"  -\" + (\n        // -f=,-file=<file>\n        f.valueName ?\n          f.names.join(\"=,-\") + \"=\" + (\n            f.valueType == \"boolean\" ? 'on|off' :\n                                       '<' + f.valueName + '>'\n          ) :\n        // -f, -file\n        f.names.join(\", -\")\n      )\n      longestFlagName = Math.max(longestFlagName, flagName.length)\n      flagNames.push(flagName)\n    }\n\n    for (let i = 0; i < opts.length; i++) {\n      let f = opts[i]\n      let names = flagNames[i]\n      let descr = f.description\n      if (!f.description) {\n        // default to \"Set flagname\" (\"Enable flagname\" for bool flags)\n        descr = f.valueType ? \"Set \" : \"Enable \" + f.names.reduce(\n          (a,s) => (s.length > a.length ? s : a), // pick longest name\n          \"\"\n        )\n      }\n      s += `${names.padEnd(longestFlagName, \" \")}  ${descr}`\n      if (i + 1 < opts.length) {\n        s += \"\\n\"\n      }\n    }\n  }\n\n  // end with trailer\n  if (trailer) {\n    s += \"\\n\" + subvars(trailer.replace(/[\\n\\s]+$/, \"\"))\n  }\n\n  return s\n}\n\n", "import { stdoutStyle, stderrStyle } from \"./termstyle\"\nimport { memoize } from \"./memoize\"\nimport { prog } from \"./cli\"\nimport { Console } from \"console\"\n\ndeclare const DEBUG :boolean\n\nexport interface Env {\n  log :typeof log\n}\n\nexport enum LogLevel {\n  Error = 0,  // only log errors\n  Warn,       // log errors and warnings\n  Info,       // log errors, warnings and info\n  Debug,      // log everything\n}\n\nlet log_console = console\nlet log_colorMode :boolean|undefined = undefined\n\nexport const log = new class Log {\n  readonly ERROR = LogLevel.Error\n  readonly WARN  = LogLevel.Warn\n  readonly INFO  = LogLevel.Info\n  readonly DEBUG = LogLevel.Debug\n\n  level = LogLevel.Info\n\n  error(...v :any[]) :void {\n    log_console.error(stderrStyle.red(`${prog}:`), ...v)\n  }\n  warn(...v :any[]) :void {\n    if (log.level >= LogLevel.Warn) {\n      log_console.error(stderrStyle.magenta(`${prog}:`), ...v)\n    }\n  }\n  info(...v :any[]) :void {\n    if (log.level >= LogLevel.Info) {\n      log_console.log(...v)\n    }\n  }\n  readonly infoOnce = memoize(() => log.info.bind(log))\n  readonly debug = log_debug\n\n  get colorMode() :boolean|undefined {\n    return log_colorMode\n  }\n  set colorMode(colorMode :boolean|undefined) {\n    if (log_colorMode === colorMode) {\n      return\n    }\n    log_colorMode = colorMode\n    if (colorMode === undefined) { // auto\n      log_console = console\n    } else {\n      log_console = new Console({\n        stdout: process.stdout,\n        stderr: process.stderr,\n        colorMode\n      })\n    }\n  }\n}\n\nexport default log\n\nfunction log_debug(...v :any[]) {\n  if (log.level >= LogLevel.Debug) {\n    let meta = \"\"\n\n    if (DEBUG) {\n      // stack traces are only usefil in debug builds (not mangled)\n      const e :any = {} ; Error.captureStackTrace(e, log_debug)\n      const frames = (e.stack ? e.stack.split(\"\\n\",5) : [])\n      const f = frames[1]  // stack frame\n      let m = f && /at (\\w+)/.exec(f)\n      if (m) {\n        meta = \" \" + m[1]\n      } else if (!m && frames[2]) {\n        if (m = frames[2] && /at (\\w+)/.exec(frames[2])) {\n          meta = ` ${m[1]} \u2192 ${stdoutStyle.italic(\"f\")}`\n        }\n      }\n    }\n\n    // evaluate first function argument\n    if (typeof v[0] == \"function\") {\n      v[0] = v[0]()\n    }\n\n    log_console.log(stdoutStyle.bold(stdoutStyle.blue(`[DEBUG${meta}]`)), ...v)\n  }\n}\n", "import * as fs from \"fs\"\nimport { PathLike } from \"fs\"\nimport * as Path from \"path\"\nimport * as crypto from \"crypto\"\nimport { chmodp, Modifier as ChModModifier, editFileMode } from \"./chmod\"\nimport { clock, tildePath } from \"./util\"\nimport { stdoutStyle } from \"./termstyle\"\nimport log from \"./log\"\nimport { file as filedecl, FileWriteOptions } from \"../estrella\"\n\nconst fsp = fs.promises\n\n// fileModificationLog contains a list of [filename,Date.now()] of files that where\n// modified through the API. This data is used by watch.\nexport const fileModificationLog :{[filename:string]:number} = {}\n\nfunction fileModificationLogAppend(filename :PathLike) {\n  // TODO figure out a way to make it not grow unbounded with variable file names\n  fileModificationLog[Path.resolve(String(filename))] = clock()\n}\n\nexport function fileWasModifiedRecentlyByUser(filename :string) {\n  const ageThreshold = 30000\n  const time = fileModificationLog[Path.resolve(filename)]\n  if (time !== undefined && clock() - time <= ageThreshold) {\n    return true\n  }\n  return false\n}\n\n// trick to make TypeScript type check our definitions here against those in estrella.d.ts\nexport const _ts_check_file :typeof filedecl = file\n\n\n// file() reads all contents of a file (same as file.read)\nexport function file(filename :PathLike, options :{encoding:string,flag?:string}|string) :Promise<string>\nexport function file(filename :PathLike, options :{encoding?:null,flag?:string}) :Promise<Buffer>\nexport function file(filename :PathLike) :Promise<Buffer>\nexport function file(\n  filename: PathLike,\n  options? :{encoding?:string|null,flag?:string}|string,\n) :Promise<string|Buffer> {\n  return fsp.readFile(filename, options as any)\n}\n\nfile.editMode = editFileMode\n\n\nfile.chmod = (filename :PathLike, modifier :ChModModifier) => {\n  fileModificationLogAppend(filename)\n  return chmodp(filename, modifier)\n}\n\n\nfunction read(\n  filename :PathLike,\n  options :{encoding:BufferEncoding, flag?:fs.OpenMode} | BufferEncoding\n) :Promise<string>\n\nfunction read(\n  filename :PathLike,\n  options :{encoding?:null, flag?:fs.OpenMode} | null\n) :Promise<Buffer>\n\nfunction read(filename :PathLike) :Promise<Buffer>\n\nfunction read(\n  filename :PathLike,\n  options? : { encoding? :BufferEncoding|null, flag? :fs.OpenMode }\n           | BufferEncoding\n           | null\n) :Promise<string|Buffer> {\n  return fsp.readFile(filename, options)\n}\n\nfile.read = read\n\nfile.stat = fsp.stat\n\nfile.mtime = (filename :PathLike) :Promise<number|null> => {\n  return fsp.stat(filename).then(st => st.mtimeMs).catch(_ => null)\n}\n\nfile.readall = (...filenames :PathLike[]) =>\n  Promise.all(filenames.map(fn => fsp.readFile(fn)))\n\nfile.readallText = (encoding :string|null|undefined, ...filenames :PathLike[]) =>\n  Promise.all(filenames.map(fn => fsp.readFile(fn, {\n    encoding: (encoding||\"utf8\") as BufferEncoding\n  })))\n\nfile.write = (filename :PathLike, data :string|Uint8Array, options? :FileWriteOptions) => {\n  fileModificationLogAppend(filename)\n  return fsp.writeFile(filename, data, options).then(() => {\n    let relpath = Path.relative(process.cwd(), String(filename))\n    if (relpath.startsWith(\"..\" + Path.sep)) {\n      relpath = tildePath(filename)\n    }\n    log.info(stdoutStyle.green(`Wrote ${relpath}`))\n  })\n}\n\nfunction sha1(filename :PathLike) :Promise<Buffer>\nfunction sha1(filename :PathLike, outputEncoding :\"latin1\"|\"hex\"|\"base64\") :Promise<string>\n\nfunction sha1(\n  filename :PathLike,\n  outputEncoding? :crypto.HexBase64Latin1Encoding,\n) :Promise<Buffer|string> {\n  return new Promise<Buffer|string>((resolve, reject) => {\n    const reader = fs.createReadStream(filename)\n    const h = crypto.createHash('sha1')\n    reader.on('error', reject)\n    reader.on('end', () => {\n      h.end()\n      resolve(outputEncoding ? h.digest(outputEncoding) : h.digest())\n    })\n    reader.pipe(h)\n  })\n}\n\nfile.sha1 = sha1\n\nfile.copy = (srcfile :PathLike, dstfile :PathLike, failIfExist? :boolean) => {\n  let mode = fs.constants.COPYFILE_FICLONE  // copy-on-write (only used if OS supports it)\n  if (failIfExist) {\n    mode |= fs.constants.COPYFILE_EXCL\n  }\n  fileModificationLogAppend(dstfile)\n  return fsp.copyFile(srcfile, dstfile, mode)\n}\n\nfile.move = (oldfile :PathLike, newfile :PathLike) => {\n  fileModificationLogAppend(newfile)\n  return fsp.rename(oldfile, newfile)\n}\n\nfile.mkdirs = (dir :PathLike, mode? :fs.Mode) :Promise<boolean> => {\n  return fsp.mkdir(dir, {recursive:true, mode}).then(s => !!s && s.length > 0)\n}\n", "import * as fs from \"fs\"\nimport * as Path from \"path\"\nimport * as chokidar from \"chokidar\"\nimport { fileWasModifiedRecentlyByUser } from \"./file\"\nimport log from \"./log\"\n\n\nexport function watch(path, options, cb) {\n  if (cb === undefined) { // call form: watch(path, cb)\n    cb = options\n    options = undefined\n  }\n  options = {\n    // Defaults\n    persistent: true,\n    ignoreInitial: true,\n    ignored: /(^|[\\/\\\\])\\../, // ignore dotfiles\n    persistent: true,\n    disableGlobbing: true,\n    followSymlinks: false,\n\n    // user override\n    ...(options || {})\n  }\n\n  // extract non-chokidar options\n  const latency = options.latency === undefined ? 1 : options.latency\n  delete options.latency\n\n  const filter = options.filter === undefined ? /\\.(?:js|ts|jsx|tsx)$/ : options.filter\n  delete options.filter\n\n  const changedFiles = new Set()\n  let timer = null\n\n  function flush() {\n    timer = null\n    const p = cb(Array.from(changedFiles))\n    changedFiles.clear()\n    if (p instanceof Promise) {\n      // pause dispatch (just enqueue) until resolved\n      p.then(() => {\n        timer = null\n        if (changedFiles.size > 0) {\n          flush()\n        }\n      }).catch(err => {\n        watchPromise.cancel(err)\n      })\n      timer = 1 // this prevent flushing\n    }\n  }\n\n  const onchange = (ev, file) => {\n    if (filter && !filter.test(file)) {\n      log.debug(()=>`fs watcher: event: ${ev} ${file} (ignored by filter)`)\n      return\n    }\n    if (fileWasModifiedRecentlyByUser(file)) {\n      log.debug(()=>`fs watcher: self-originating event: ${ev} ${file} (ignored)`)\n      return\n    }\n    log.debug(()=>`fs watcher: event: ${ev} ${file}`)\n    changedFiles.add(file)\n    if (timer === null) {\n      timer = setTimeout(flush, latency)\n    }\n  }\n\n  // Initialize chokidar watcher.\n  // arg0: path; file, dir, glob, or array\n  const watcher = chokidar.watch(path, options);\n\n  // Add event listeners.\n  watcher\n    .on('all', onchange)\n    .on('error', error => log.warn(`fs watcher: ${error}`))\n    .on('ready', () => log.debug('fs watcher: initial scan complete'))\n\n  var reject_, resolve_\n  var watchPromise = new Promise((resolve, reject) => {\n    resolve_ = resolve\n    reject_ = reject\n  })\n\n  let cancelled = false\n  watchPromise.cancel = error => {\n    clearTimeout(timer)\n    if (!cancelled) {\n      cancelled = true\n      watcher.close().then(resolve_).catch(reject_)\n    }\n    if (error) {\n      reject_(error)\n    }\n  }\n\n  return watchPromise\n}\n\n\n// scandir(\n//   dir      :string|string[],\n//   filter?  :RegExp|null,\n//   options? :WatchOptions|null,\n// ) :Promise<string[]>\nexport async function scandir(dir, filter, options) {\n  if (!options) { options = {} }\n  if (!fs.promises || !fs.promises.opendir) {\n    // opendir was added in node 12.12.0\n    throw new Error(`not implemented for nodejs <12.12.0`) // TODO\n  }\n  const files = []\n  const basedir = dir\n  const visited = new Set()\n  async function visit(dir, reldir) {\n    if (visited.has(dir)) {\n      // cycle\n      return\n    }\n    visited.add(dir)\n    const d = await fs.promises.opendir(dir)\n    // Note: d.close() is called implicitly by the iterator/generator\n    for await (const ent of d) {\n      let name = ent.name\n      if (ent.isDirectory()) {\n        if (options.recursive) {\n          await visit(Path.join(dir, name), Path.join(reldir, name))\n        }\n      } else if (ent.isFile() || ent.isSymbolicLink()) {\n        if (filter && filter.test(name)) {\n          files.push(Path.join(reldir, name))\n        }\n      }\n    }\n  }\n  return visit(Path.resolve(dir), \".\").then(() => files.sort())\n}\n", "import * as Path from \"path\"\nimport * as fs from \"fs\"\n\nimport { jsonparseFile } from \"./util\"\n\nconst { dirname, basename } = Path\n\n\nexport function findTSC(cwd) {\n  let npmPath = \"\"\n  let tmpcwd = process.cwd()\n  if (cwd) { process.chdir(cwd) }\n  try {\n    npmPath = require.resolve(\"typescript\")\n  } catch (_) {\n  } finally {\n    if (cwd) { process.chdir(tmpcwd) }\n  }\n  if (npmPath) {\n    const find = Path.sep + \"node_modules\" + Path.sep\n    let i = npmPath.indexOf(find)\n    if (i != -1) {\n      return Path.join(npmPath.substr(0, i + find.length - Path.sep.length), \".bin\", \"tsc\")\n    }\n  }\n  // not found in node_modules\n  return \"tsc\"\n}\n\n\nexport function findTSConfigFile(dir) {\n  // start at dir and search for dir + tsconfig.json,\n  // moving to the parent dir until found or until parent dir is the root dir.\n  dir = Path.resolve(dir)\n  const root = Path.parse(dir).root\n  while (true) {\n    let path = Path.join(dir, \"tsconfig.json\")\n    if (fs.existsSync(path)) {\n      return path\n    }\n    dir = dirname(dir)\n    if (dir == root) {\n      // don't search \"/\"\n      break\n    }\n  }\n  return null\n}\n\n\nconst TS_CONFIG_FILE = Symbol(\"TS_CONFIG_FILE\")\nconst TS_CONFIG = Symbol(\"TS_CONFIG\")\n\n\nexport function getTSConfigFileForConfig(config) {\n  let file = config[TS_CONFIG_FILE]\n  if (file === undefined) {\n    if (config.tsc === \"off\" || config.tsc === false) {\n      config[TS_CONFIG_FILE] = file = null\n    } else {\n      let dir = config.cwd || process.cwd()\n      if (config.entryPoints && config.entryPoints.length > 0) {\n        // TODO: pick the most specific common denominator dir path of all entryPoints\n        dir = Path.resolve(dir, config.entryPoints[0])\n      }\n      config[TS_CONFIG_FILE] = file = findTSConfigFile(dir)\n    }\n  }\n  return file\n}\n\n\nexport function getTSConfigForConfig(config) {\n  let tsconfig = config[TS_CONFIG]\n  if (tsconfig !== undefined) {\n    return tsconfig\n  }\n  const file = getTSConfigFileForConfig(config)\n  if (file) {\n    try {\n      return config[TS_CONFIG] = jsonparseFile(file)\n    } catch(err) {\n      if (DEBUG) {\n        console.warn(`[tsutil.getTSConfigForConfig] ${err.stack||err}`)\n      }\n    }\n  }\n  return config[TS_CONFIG] = null\n}\n\n", "import * as Path from \"path\"\nimport * as fs from \"fs\"\nimport { spawn } from \"child_process\"\n\nimport { json, jsonparseFile, findInPATH } from \"./util\"\nimport { stdoutStyle, stderrStyle } from \"./termstyle\"\nimport { screen } from \"./screen\"\nimport { findTSC, findTSConfigFile } from \"./tsutil\"\nimport log from \"./log\"\n\nconst { dirname, basename } = Path\n\n\n// defaultTSRules maps TS diagnostics codes to severity levels.\n// The special value IGNORE can be used to completely silence a diagnostic.\n// For diagnostic codes not listed, the default DiagnosticCategory for a\n// certain diagnostic is used.\nexport const defaultTSRules = {\n  6031: \"IGNORE\",  // starting compilation\n  6194: \"IGNORE\",  // Found N errors. Watching for file changes.\n  6133: \"WARNING\", // unused variable, parameter or import\n  2531: \"WARNING\", // Object is possibly 'null'\n  7006: \"WARNING\", // Parameter 'x' implicitly has an 'any' type.\n  7015: \"WARNING\", // Element implicitly has an 'any' type because index expression is not ...\n  7053: \"WARNING\", // Element implicitly has an 'any' type because expression of type can't be ...\n}\n\n\nconst IGNORE  = 0\n    , INFO    = 1\n    , WARNING = 2\n    , ERROR   = 3\n\n\nconst severities = {IGNORE,INFO,WARNING,ERROR}\n\n\nfunction addTSRules(dst, src) {\n  for (let k of Object.keys(src)) {\n    let v = severities[String(src[k]).toUpperCase()]\n    if (v === undefined) {\n      throw new Error(\n        `Invalid value for TS rule ${k}: ${json(v)} -- expected value to be one of: `+\n        Object.keys(severities).map(json).join(\", \")\n      )\n    }\n    dst[k] = v\n  }\n}\n\n\n// returns a promise which resolves to a boolean \"no errors\", when the TSC process ends.\n// Note that in watch mode, the promise only resolves after explicitly calling cancel.\n// The returned promise is cancellable. I.e. p.cancel()\n//\nexport function tslint(options /*:TSLintOptions*/) {\n  if (!options) { options = {} }\n  let cancellation = {\n    cancelled: false,\n    cancel(){},\n  }\n  let p = new Promise((resolve, reject) => {\n\n  if (options.mode == \"off\") {\n    return resolve(true)\n  }\n\n  const logInfo = options.quiet ? ()=>{} : console.log.bind(console)\n  const cwd = options.cwd || process.cwd()\n\n  // find tsconfig.json file\n  let tsconfigFile = (\n    options.tsconfigFile ||\n    findTSConfigFile(options.srcdir ? Path.resolve(cwd, options.srcdir) : cwd)\n  )\n  if (options.mode != \"on\" && !tsconfigFile) {\n    // no tsconfig file found -- in auto mode, we consider this \"not a TypeScript project\".\n    return resolve(true)\n  }\n\n  // find tsc program\n  let tscprog = findTSC(options.cwd /* ok if undefined */)\n  if (tscprog == \"tsc\" && options.mode != \"on\") {\n    // look up tsc in PATH\n    if (!(tscprog = findInPATH(tscprog))) {\n      // we found a tsconfig.json file but not tsc\n      console.warn(\n        stderrStyle.orange(prog + \":\") + ` tsc not found in node_modules or PATH.` +\n        ` However a tsconfig.json file was found in ` +\n        Path.relative(process.cwd(), dirname(tsconfigFile)) + `.`\n        ` Set tslint options.tsc=\"off\" or pass -no-diag on the command line.`\n      )\n      return resolve(true)\n    }\n  }\n\n  // rules\n  const tsrules = {}\n  addTSRules(tsrules, defaultTSRules)\n  if (options.rules) {\n    addTSRules(tsrules, options.rules)\n  }\n\n  // CLI arguments\n  let args = [\n    \"--noEmit\",\n    options.colors && \"--pretty\",\n    options.watch && \"--watch\",\n    tsconfigFile && \"--project\", tsconfigFile,\n  ].concat(options.args || []).filter(a => a)\n\n  log.debug(() => `spawning process ${tscprog} ${json(args,2)}`)\n\n  // spawn tsc process\n  const p = spawn(tscprog, args, {\n    stdio: ['inherit', 'pipe', 'inherit'],\n    cwd,\n  })\n\n  // kill process on exit to avoid EPIPE errors\n  const onProcessExitHandler = () => {\n    try { p.kill() } catch (_) {}\n  }\n  process.on('exit', onProcessExitHandler)\n\n  // cancellation handler\n  cancellation.cancel = () => {\n    // called just once (guarded by user cancel function)\n    p.kill()\n  }\n\n  const infoStyle  = s => s\n      , warnStyle  = stdoutStyle.orange\n      , errorStyle = stdoutStyle.red\n      , okStyle    = stdoutStyle.green\n\n  const _TS_buf = Buffer.from(\" TS\")\n  const Found__buf = Buffer.from(\"Found \")\n  const ANSI_clear_buf = Buffer.from(\"\\x1bc\")\n  const Starting_compilation_buf = Buffer.from(\"tarting compilation\")\n  const Starting_incremental_compilation_buf = Buffer.from(\"tarting incremental compilation\")\n\n  const tsmsgbuf = []\n  let tscode = 0\n  let lastRunHadErrors = false\n  let stats = {\n    errors: 0,\n    warnings: 0,\n    other: 0,\n    reset() {\n      this.errors = 0\n      this.warnings = 0\n      this.other = 0\n    },\n  }\n\n  let isIdle = false\n\n\n  function onSessionEnd() {\n    if (!options.quiet || stats.errors >= 0) {\n      options.watch && console.log(screen.banner(\"\u2014\"))\n      let summary = []\n      if (stats.errors > 0) {\n        summary.push(errorStyle(\"TS: \" + plural(`$ error`, `$ errors`, stats.errors)))\n      } else {\n        summary.push(okStyle(\"TS: OK\"))\n      }\n      if (stats.warnings > 0) {\n        summary.push(warnStyle(plural(`$ warning`, `$ warnings`, stats.warnings)))\n      }\n      if (stats.other > 0) {\n        summary.push(plural(`$ message`, `$ messages`, stats.other))\n      }\n      console.log(summary.join(\"   \"))\n      options.watch && console.log(screen.banner(\"\u2014\"))\n    }\n    lastRunHadErrors = stats.errors > 0\n    options.onEnd && options.onEnd(stats)\n    stats.reset()\n    isIdle = true\n  }\n\n\n  // called when tsmsgbuf contains one or more lines of one TypeScript message.\n  function flushTSMessage(compilationPassCompleted) {\n    // console.log(`------------------- TS${tscode} ------------------`)\n    // console.log({ tsmsgbuf: tsmsgbuf.map(b => b.toString(\"utf8\")) })\n\n    // reset buffer\n    const lines = tsmsgbuf.slice()\n    tsmsgbuf.length = 0\n\n    if (tscode == 0) {\n\n      // pick the first non-empty line\n      let i = 0\n      let line0 = lines[i++]\n      while (line0.length == 0 || line0[0] == 0x0A && i < lines.length) {\n        line0 = lines[i++]\n      }\n\n      // check if the line is the \"starting\" message\n      if (line0.includes(Starting_compilation_buf) ||\n          line0.includes(Starting_incremental_compilation_buf)\n      ) {\n        stats.reset()\n        // ignore \"Starting compilation [in watch mode...]\" message\n        // alt spelling in more recent typescript versions:\n        //   \"Starting incremental compilation...\"\n        return compilationPassCompleted && onSessionEnd()\n      }\n\n      if (lines.every(line => line.length <= 1)) {\n        // ignore empty message\n        return compilationPassCompleted && onSessionEnd()\n      }\n    } else {\n      const errorRe = /(?:\\x1b\\[\\d+m|)error(?:\\x1b\\[\\d+m|)/g\n      let line0 = lines.shift().toString(\"utf8\")\n      switch (tsrules[tscode]) {\n        case IGNORE: return compilationPassCompleted && onSessionEnd()\n\n        case INFO:\n          // rewrite potentially ANSI-colored first line \"error\"\n          line0 = line0.replace(errorRe, infoStyle(\"info\"))\n          restyleSrcLineWaves(lines, infoStyle)\n          stats.other++\n          break\n\n        case WARNING:\n          // rewrite potentially ANSI-colored first line \"error\"\n          line0 = line0.replace(errorRe, warnStyle(\"warning\"))\n          restyleSrcLineWaves(lines, warnStyle)\n          stats.warnings++\n          break\n\n        default: // ERROR or other\n          if (errorRe.test(line0)) {\n            stats.errors++\n          } else {\n            stats.other++\n          }\n          break\n      }\n      process.stdout.write(line0)\n    }\n\n    // write lines to stdout\n    lines.forEach(v => process.stdout.write(v))\n\n    compilationPassCompleted && onSessionEnd()\n  }\n\n\n  function restyleSrcLineWaves(lines, stylefn) {\n    for (let i = 1; i < lines.length; i++) {\n      let line = lines[i]\n      if (line.includes(0x7e)) { // ~\n        let s = line.toString(\"utf8\") // \"\\x1b[91m\"\n        s = s.replace(/\\x1b\\[\\d+m(\\s*~+)/g, stylefn(\"$1\"))\n        lines[i] = s  // ok to set string instead of Buffer\n      }\n    }\n  }\n\n\n  function plural(singular, plural, n) {\n    return (n == 1 ? singular : plural).replace(/\\$/g, n)\n  }\n\n  lineReader(p.stdout, (line, flush) => {\n    if (!options.clearScreen) {\n      line = stripANSIClearCode(line)\n    }\n    if (flush) {\n      if (line.length > 0) {\n        tsmsgbuf.push(line)\n      }\n      if (tsmsgbuf.length > 0) {\n        flushTSMessage()\n      }\n      return\n    }\n\n    if (isIdle && line.length > 1) {\n      // first non-empty line after isIdle state has been entered marks the start of\n      // a new session.\n      isIdle = false\n      options.onRestart && options.onRestart()\n    }\n\n    if (line.includes(Found__buf)) {\n      let s = stripANSICodesStr(line.toString(\"utf8\"))\n      if (/^(?:\\[[^\\]]+\\] |[\\d\\:PAM \\-]+|)Found \\d+ error/.test(s)) {\n        // TypeScript has completed a compilation pass\n        flushTSMessage(true)\n        tscode = 0\n        return // don't add this line to line buffer\n      } else {\n        flushTSMessage(false)\n      }\n      tscode = 0\n    } else {\n      // console.log(\"--> \" + line.subarray(0, line.length-1).toString(\"utf8\"))\n      if (line.includes(_TS_buf)) {\n        const s = line.toString(\"utf8\")\n        const m = /(?:\\x1b\\[\\d+m|)error(?:\\x1b\\[\\d+m\\x1b\\[\\d+m|) TS(\\d+)\\:/.exec(s)\n        // const m = /(?:\\x1b\\[\\d+m|)error(?:\\x1b\\[\\d+m|) TS(\\d+)\\:/.exec(s)\n        let tscode2 = m ? parseInt(m[1]) : 0\n        if (tscode2 > 0 && !isNaN(tscode2)) {\n          if (tsmsgbuf.length > 0) {\n            flushTSMessage()\n          }\n          tscode = tscode2\n        }\n      }\n    }\n    tsmsgbuf.push(line)\n  })\n\n  // lineReader(p.stderr, line => {\n  //   process.stderr.write(line)\n  // })\n\n  p.on('close', code => {\n    // console.log(`tsc exited with code ${code}`)\n    process.removeListener('exit', onProcessExitHandler)\n    resolve(!lastRunHadErrors)\n  })\n\n  function stripANSICodesStr(s) {\n    return s.replace(/\\x1b\\[\\d+m/g, \"\")\n  }\n\n  function stripANSIClearCode(buf) {\n    // strip \"clear\" ANSI code is present in buf\n    let i = buf.indexOf(ANSI_clear_buf)\n    return (\n      i == -1 ? buf :\n      i == 0 ? buf.subarray(3) :\n      Buffer.concat([buf.subarray(0,i), buf.subarray(i+3)], buf.length - 3)\n    )\n  }\n  }) // Promise\n  p.cancel = () => {\n    if (!cancellation.cancelled) {\n      cancellation.cancelled = true\n      cancellation.cancel()\n    }\n    return p\n  }\n  return p\n} // end function tslint\n\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\n\nfunction lineReader(r, onLine) {\n  let bufs = [], bufz = 0\n  const readbuf = data => {\n    let offs = 0\n    while (true) {\n      let i = data.indexOf(0x0A, offs)\n      if (i == -1) {\n        if (offs < data.length - 1) {\n          const chunk = data.subarray(offs)\n          bufs.push(chunk)\n          bufz += chunk.length\n        }\n        break\n      }\n      i++\n      let buf = data.subarray(offs, i)\n      if (bufz > 0) {\n        buf = Buffer.concat(bufs.concat(buf), bufz + buf.length)\n        bufs.length = 0\n        bufz = 0\n      }\n      onLine(buf, false)\n      offs = i\n    }\n  }\n  const flush = () => {\n    if (bufs.length > 0) {\n      onLine(Buffer.concat(bufs, bufz), true)\n    } else {\n      onLine(emptyBuffer, true)\n    }\n  }\n\n  // TEST\n  // readbuf(Buffer.from(\"hello\"))\n  // readbuf(Buffer.from(\" world\\n\"))\n  // readbuf(Buffer.from(\"How\"))\n  // readbuf(Buffer.from(\"'s \"))\n  // readbuf(Buffer.from(\"it go\"))\n  // readbuf(Buffer.from(\"ing?\\n\"))\n  // readbuf(Buffer.from(\"quite well\\nI hope!\\nBye\\n\"))\n  // readbuf(Buffer.from(\"bye.\"))\n  // flush()\n  // lineReader(0, line => {\n  //   console.log({line:line.toString(\"utf8\")})\n  // })\n\n  r.on(\"data\", readbuf)\n  r.on(\"close\", flush)\n  r.on(\"end\", flush)\n}\n", "import { BuildConfig } from \"../estrella\"\nimport log from \"./log\"\n\nexport function configure(config :BuildConfig) {\n  if (!config.run) {\n    return\n  }\n  log.debug(\"run.configure\")\n  console.log(\"TODO config\")\n}\n", "import { json, tildePath } from \"./util\"\nimport log from \"./log\"\nimport { TypeScriptAPI, TSInterface, TSTypeProp } from \"../estrella\"\n\n// hack to make tsc work vanilla with our weird srcdir-based tsconfig (needed for examples to work)\nimport * as TS from \"../node_modules/typescript/lib/typescript.d\"\n\n// type Program = TS.Program\ntype CompilerOptions = TS.CompilerOptions\ntype InterfaceDeclaration = TS.InterfaceDeclaration\ntype SourceFile = TS.SourceFile\n\nexport function createTSAPI(tsapi? :typeof TS) :TypeScriptAPI | null {\n  let ts = tsapi as typeof TS\n  if (!ts) {\n    // load typescript module if available, or return null\n    log.debug(\"typescript API requested; attempting to load typescript module\")\n    try {\n      const X = require  // work around an issue in esbuild with require.X()\n      ts = X(\"typescript\") as typeof TS\n      if (parseFloat(ts.versionMajorMinor) < 3.5) {\n        // typescript too old\n        log.warn(\n          `typescript ${ts.version} is too old; disabling \"ts\" API.\\n` +\n          `  You are seeing this message because you are importing the ts API.\\n` +\n          `  Either install a more recent version of typescript or remove the ts import.`\n        )\n        return null\n      }\n      log.debug(() =>\n        `loaded typescript ${ts.version} from ${tildePath(X.resolve(\"typescript\"))}`)\n    } catch (_) {\n      // API unavailable\n      log.debug(() => `failed to load typescript; module unavailable`)\n      return null\n    }\n  }\n\n  const compilerHostCache = new Map<string,[TS.CompilerHost,CompilerOptions]>()\n\n  function getCompilerHost(options: CompilerOptions) :[TS.CompilerHost,CompilerOptions] {\n    const cacheKey = json(Object.keys(options).sort().map(k => [k,options[k]]))\n    const cacheEntry = compilerHostCache.get(cacheKey)\n    if (cacheEntry) {\n      log.debug(\"ts.getCompilerHost cache hit\")\n      return cacheEntry\n    }\n    options = {\n      newLine: ts.NewLineKind.LineFeed, // TS 4.0.3 crashes if not set\n      ...options\n    }\n    const host = ts.createCompilerHost(options, /*setParentNodes*/true)\n    const result :[TS.CompilerHost,CompilerOptions] = [host, options]\n    compilerHostCache.set(cacheKey, result)\n    log.debug(\"ts.getCompilerHost cache miss\")\n    return result\n  }\n\n\n  async function parse(source :string, options?: CompilerOptions) :Promise<SourceFile>\n\n  async function parse(\n    source :{[filename:string]:string},\n    options?: CompilerOptions,\n  ) :Promise<{[filename:string]:SourceFile}>\n\n  async function parse(\n    source :string | {[filename:string]:string},\n    options?: CompilerOptions,\n  ) :Promise<SourceFile|{[filename:string]:SourceFile}> {\n    const sources = typeof source == \"string\" ? {\"/<source>/a.ts\":source} : source\n    const filenames = Object.keys(sources)\n\n    const [host, compilerOptions] = getCompilerHost(options||{})\n\n    const readFile = host.readFile\n    host.readFile = (filename: string) => {\n      // console.log(\"readFile\", filename)\n      if (filename in sources) {\n        return sources[filename]\n      }\n      return readFile(filename)\n    }\n\n    // This is SLOW. Usually around 500ms for even a single empty file\n    const prog = ts.createProgram(filenames, compilerOptions, host)\n\n    if (typeof source == \"string\") {\n      return prog.getSourceFile(filenames[0])!\n    }\n    const nodes :{[filename:string]:SourceFile} = {}\n    for (let fn of filenames) {\n      nodes[fn] = prog.getSourceFile(fn)!\n    }\n    return nodes\n  }\n\n\n  async function parseFile(srcfile :string, options?: CompilerOptions) :Promise<SourceFile> {\n    // TODO worker\n    return _parsefile(srcfile, options)\n  }\n\n\n  function _parsefile(srcfile :string, options?: CompilerOptions) :SourceFile {\n    const [host, compilerOptions] = getCompilerHost(options || {})\n    const prog = ts.createProgram([srcfile], compilerOptions, host)\n    return prog.getSourceFile(srcfile)!\n  }\n\n\n  function interfaceInfo(\n    srcfile :string,\n    interfaceName :string,\n    options?: CompilerOptions,\n  ) :Promise<TSInterface|null> {\n    return interfacesInfo(srcfile, [interfaceName], options).then(v => v[0])\n  }\n\n  async function interfacesInfo(\n    srcfile :string,\n    interfaceNames :string[] | null,\n    options?: CompilerOptions,\n  ) :Promise<(TSInterface|null)[]> {\n    // TODO move ts to subprocess/worker\n    const file = _parsefile(srcfile, options)\n    return interfacesInfoAST(file, interfaceNames)\n  }\n\n\n  function interfacesInfoAST(\n    file :SourceFile,\n    interfaceNames :string[] | null,\n  ) :(TSInterface|null)[] {\n    const ifdecls = topLevelInterfaceDeclarations(file)\n\n    const shortCircuit = new Map<InterfaceDeclaration,TSInterface>()\n    const infov :(TSInterface|null)[] = []\n\n    for (let name of (interfaceNames || ifdecls.keys())) {\n      const node = ifdecls.get(name)\n      if (!node) {\n        infov.push(null)\n        continue\n      }\n      infov.push(createTSInterface(file, node, ifdecls, shortCircuit))\n    }\n\n    return infov\n  }\n\n\n  function createTSInterface(\n    file         :SourceFile,\n    ifnode       :InterfaceDeclaration,\n    ifdecls      :Map<string,InterfaceDeclaration>,\n    shortCircuit :Map<InterfaceDeclaration,TSInterface>,\n  ) :TSInterface {\n    const info1 = shortCircuit.get(ifnode)\n    if (info1) {\n      return info1\n    }\n\n    const info :TSInterface = {\n      heritage: [],\n      name:     ifnode.name.escapedText as string,\n      props    :{},\n      computedProps() {\n        const props :{[name:string]:TSTypeProp} = {}\n        for (let h of info.heritage) {\n          Object.assign(props, h.props)\n        }\n        Object.assign(props, info.props)\n        return props\n      },\n      lookupProp(name :string) :TSTypeProp|null {\n        let p :TSTypeProp|null = info.props[name]\n        if (!p) {\n          for (let h of info.heritage) {\n            if (p = h.lookupProp(name)) {\n              break\n            }\n          }\n        }\n        return p\n      },\n    }\n\n    shortCircuit.set(ifnode, info)\n\n    // heritage types (i.e. from \"Bar\" in \"interface Foo extends Bar\")\n    if (ifnode.heritageClauses) for (let hc of ifnode.heritageClauses) { // hc :HeritageClause\n      for (let t of hc.types) { // t :ExpressionWithTypeArguments\n        const expr = t.expression\n        if (ts.isIdentifier(expr)) {\n          const heritageNode = ifdecls.get(expr.escapedText as string)\n          if (heritageNode) {\n            info.heritage.push(createTSInterface(file, heritageNode, ifdecls, shortCircuit))\n          } // else just ignore it\n        }\n      }\n    }\n\n    // build info.props\n    ifnode.forEachChild(n => {\n      if (ts.isPropertySignature(n)) {\n        const prop = createTSTypeProp(n, file, info)\n        info.props[prop.name] = prop\n      }\n    })\n\n    return info\n  }\n\n\n  function createTSTypeProp(\n    n :TS.PropertySignature,\n    file :SourceFile,\n    parent :TSInterface,\n  ) :TSTypeProp {\n    // console.log(\"PropertySignature\", n.name.escapedText, n)\n    const pos = ts.getLineAndCharacterOfPosition(file, n.pos)\n\n    let _typestr :string|null = null\n    const _type = n.type\n    const name = propName(n.name)\n\n    const typeprop = {\n      name,\n      type: _type,\n      get typestr() :string {\n        if (_typestr === null) {\n          _typestr = _type ? fmt(_type, file) : \"any\"\n        }\n        Object.defineProperty(typeprop, \"typestr\", {enumerable:true, value:_typestr})\n        return _typestr\n      },\n      srcfile: file.fileName,\n      srcline: pos.line,\n      srccol:  pos.character,\n      parent,\n    }\n    return typeprop\n  }\n\n\n  function propName(n :TS.PropertyName) :string {\n    switch (n.kind) {\n\n    case ts.SyntaxKind.Identifier:\n    case ts.SyntaxKind.PrivateIdentifier:\n      return n.escapedText as string\n\n    case ts.SyntaxKind.StringLiteral:\n    case ts.SyntaxKind.NumericLiteral:\n      return n.text\n\n    case ts.SyntaxKind.ComputedPropertyName:\n      // TODO printer\n      return \"[computed]\"\n\n    default:\n      return \"?\"\n    }\n  }\n\n\n  // returns all top-level interface declarations in file\n  function topLevelInterfaceDeclarations(file :SourceFile) :Map<string,InterfaceDeclaration> {\n    const m = new Map<string,InterfaceDeclaration>()\n    ts.forEachChild(file, n => {\n      if (n.kind == ts.SyntaxKind.InterfaceDeclaration) {\n        m.set(\n          (n as InterfaceDeclaration).name.escapedText as string,\n          n as InterfaceDeclaration,\n        )\n      } else {\n        // console.log(\"unhandled n in switch:\", ts.SyntaxKind[n.kind])\n      }\n    })\n    return m\n  }\n\n\n  const basicPrinter = ts.createPrinter({\n    removeComments: true,\n    newLine: ts.NewLineKind.LineFeed,\n    omitTrailingSemicolon: true,\n    noEmitHelpers: true,\n  })\n\n\n  /*EXPORT*/ function fmt(node :TS.Node, file? :SourceFile) :string {\n    if (!file) {\n      // find source file by walking up the AST\n      let n = node\n      while (n.kind != ts.SyntaxKind.SourceFile) {\n        n = n.parent\n        if (!n) {\n          throw new Error(\"node without SourceFile parent (provide file to ts.fmt)\")\n        }\n      }\n      file = n as TS.SourceFile\n    }\n    return basicPrinter.printNode(ts.EmitHint.Unspecified, node, file)\n  }\n\n  return {\n    ts,\n    getCompilerHost,\n    parse,\n    parseFile,\n    interfaceInfo,\n    interfacesInfo,\n    interfacesInfoAST,\n    fmt,\n  }\n\n}\n\n// const programCache = new Map<string,Program>() // {srcfile:{options:program}}\n// function getProgram(srcfiles :string[], options: CompilerOptions) {\n//   const cacheKey = srcfiles.map(f => Path.resolve(f)).join(\":\") + \"\\n\" + (\n//     Object.keys(options).sort().map(k => `${options[k]}\\n`)\n//   )\n//   let prog = programCache.get(cacheKey)\n//   if (!prog) {\n//     prog = ts.createProgram(srcfiles, options)\n//     programCache.set(cacheKey, prog)\n//   }\n//   return prog\n// }\n", "#!/usr/bin/env node\nimport * as esbuild from \"esbuild\"\nimport * as fs from \"fs\"\nimport * as Path from \"path\"\nimport * as glob from \"miniglob\"\nimport * as crypto from \"crypto\"\n\nimport {\n  clock,\n  findInPATH,\n  fmtByteSize,\n  fmtDuration,\n  json,\n  jsonparse,\n  repr,\n  tildePath,\n} from \"./util\"\nimport { termStyle, stdoutStyle as style, stderrStyle } from \"./termstyle\"\nimport { memoize, isMemoized } from \"./memoize\"\nimport { screen } from \"./screen\"\nimport { scandir, watch as fswatch } from \"./watch\"\nimport { tslint, defaultTSRules } from \"./tslint\"\nimport { getTSConfigFileForConfig, getTSConfigForConfig } from \"./tsutil\"\nimport { prog, parseopt } from \"./cli\"\nimport log from \"./log\"\nimport * as cli from \"./cli\"\nimport * as run from \"./run\"\nimport * as tsapi from \"./tsapi\"\nimport { file } from \"./file\"\n\nconst { dirname, basename } = Path\n\nconst CLI_DOC = {\n  usage: \"usage: $0 [options]\",\n  flags: [\n    [\"-w, watch\"         ,\"Watch source files for changes and rebuild.\"],\n    [\"-g, debug\"         ,\"Do not optimize and define DEBUG=true.\"],\n    [\"-sourcemap\"        ,\"Generate sourcemap.\"],\n    [\"-inline-sourcemap\" ,\"Generate inline sourcemap.\"],\n    [\"-color\"            ,\"Color terminal output, regardless of TTY status.\"],\n    [\"-no-color\"         ,\"Disable use of colors.\"],\n    [\"-no-clear\"         ,\"Disable clearing of the screen, regardless of TTY status.\"],\n    [\"-no-diag\"          ,\"Disable TypeScript diagnostics.\"],\n    [\"-diag\"             ,\"Only run TypeScript diagnostics (no esbuild.)\"],\n    [\"-quiet\"            ,\"Only log warnings and errors but nothing else.\"],\n    [\"-estrella-version\" ,\"Print version of estrella and exit 0.\"],\n    [\"-estrella-debug\"   ,\"Enable debug logging of estrella itself.\"],\n  ],\n}\n\nconst CLI_DOC_STANDALONE = {\n  usage: \"usage: $0 [options] <srcfile> ...\",\n  flags: CLI_DOC.flags.concat([\n    [\"-bundle \"    ,\"Bundle all dependencies into the output files.\"],\n    [\"-minify \"    ,\"Simplify and compress generated code.\"],\n    [\"-o, outfile\" ,\"Write output to <file> instead of stdout.\", \"<file>\"],\n    [\"-outdir\"     ,\"Write output to <dir> instead of stdout.\", \"<dir>\"],\n    [\"-esbuild\"    ,\"Pass arbitrary JSON to esbuild's build function.\", \"<json>\"],\n  ]),\n  trailer: `\nExample of using estrella without a build script:\n  $0 -o out/app.js main.ts\n    This compile main.ts and writes the output to out/app.js\n\nExample of using estrella with a build script:\n  1. Create a file called build.js with the following contents:\n       #!/usr/bin/env node\n       const { build } = require(\"estrella\")\n       build({\n         entry: \"main.ts\",\n         outfile: \"out/main.js\",\n       })\n  2. Make that file executable and run it:\n       chmod +x build.js\n       ./build.js\n  You can now customize your build behavior by changing build.js.\n  Try ./build.js -help\n\nSee https://github.com/rsms/estrella for full documentation.\n  `\n}\n\n// cli_ready resolved when CLI arguments have been fully processed.\n//\n// Parsing of CLI arguments happens in two phases when estrella runs from a user script.\n//   1. estrella built-in arguments are parsed, a cliopts.parse function is added.\n//   2. the user script executes, possibly calling cliopts.parse to parse custom arguments.\n//   3. a runloop frame later, cli_ready resolves.\n// This enables user scripts to extend the CLI options.\n//\n// Note that when estrella is run directly, CLI arguments are parsed in a single phase\n// and this does not apply. In that case cli_ready is resolved immediately.\n//\nlet cli_ready = Promise.resolve()\n\n// cliopts and cliargs are special objects exported in the API.\n// They are populated by this script's body when estrella runs from a user script,\n// otherwise these are populated by main()\nlet cliopts = {}, cliargs = []\n\n\n// keys of the config object passed to main/build which are specific to this program\n// and not accepted by esbuild.\n// Should match keys of BuildConfig struct in estrella.d.ts\nconst buildConfigKeys = new Set([\n  \"clear\",\n  \"cwd\",\n  \"debug\",\n  \"entry\",\n  \"onEnd\",\n  \"onStart\",\n  \"outfileMode\",\n  \"quiet\",\n  \"run\",\n  \"title\",\n  \"tsc\",\n  \"tsrules\",\n  \"watch\",\n])\n\nconst IS_MAIN_CALL = Symbol(\"IS_MAIN_CALL\")\nconst CANCELED = Symbol(\"CANCELED\")\n\nfunction EMPTYFUN(){}\n\n// ---------------------------------------------------------------------------------------------\n\n// setErrorExitCode(code:number=1) causes the program to exit with the provied code\n// in case it exits cleanly.\n// This is used to make it possible to exit with an error when there are multiple\n// builds happening.\n//\nlet _setErrorExitCode = false\nfunction setErrorExitCode(code) {\n  if (!_setErrorExitCode) {\n    _setErrorExitCode = true\n    let overrideCode = code || 1\n    process.exitCode = overrideCode\n    process.on(\"exit\", code => { process.exit(code || overrideCode) })\n  }\n}\n\n\nfunction processConfig(config) {\n  // support use of both entry and entryPoints\n  log.debug(()=>`input config ${repr(config)}`)\n  if (!config.entryPoints) {\n    config.entryPoints = []\n  }\n  if (config.entry) {\n    if (Array.isArray(config.entry)) {\n      config.entryPoints = config.entryPoints.concat(config.entry)\n    } else {\n      config.entryPoints.push(config.entry)\n    }\n  }\n  delete config.entry\n  if (config.entryPoints.length == 0) {\n    // No entryPoints provided. Try to read from tsconfig include or files\n    log.debug(()=>`missing entryPoints; attempting inference`)\n    config.entryPoints = guessEntryPoints(config)\n    if (config.entryPoints.length == 0) {\n      let msg = getTSConfigForConfig(config) ? \" (could not guess from tsconfig.json)\" : \"\"\n      throw new Error(`config.entryPoints is empty or not set${msg}`)\n    }\n  }\n  // here, config.entryPoints is always of type: string[]\n\n  // normalize sourcemap value to boolean|\"inline\"|\"external\"\n  if (config.sourcemap) {\n    if (config.sourcemap != \"inline\" && config.sourcemap != \"external\") {\n      config.sourcemap = true\n    }\n  } else {\n    config.sourcemap = false\n  }\n  log.debug(()=>`effective config: ${repr(config)}`)\n}\n\n\n// guessEntryPoints(config :BuildConfig) :string[]\nfunction guessEntryPoints(config) {\n  // guess from tsconfig.json file\n  const tsconfig = getTSConfigForConfig(config)\n  log.debug(()=>`getTSConfigForConfig => ${repr(tsconfig)}`)\n  if (tsconfig) {\n    if (tsconfig.files) {\n      return tsconfig.files\n    }\n    if (tsconfig.include) {\n      let files = []\n      for (let pat of tsconfig.include) {\n        log.debug(`glob.glob(${pat}) =>`, glob.glob(pat))\n        files = files.concat(glob.glob(pat))\n      }\n      if (tsconfig.exclude) {\n        for (let pat of tsconfig.exclude) {\n          files = files.filter(fn => !glob.match(pat, fn))\n        }\n      }\n      // return the first file remaining (if any)\n      return files.slice(0, 1)\n    }\n  }\n  return []\n}\n\n\nfunction esbuildOptionsFromConfig(config) {\n  let esbuildOptions = {}\n  // esbuildOptionKeyMap maps legacy esbuild BuildOptions keys to current ones\n  const esbuildOptionKeyMap = {\n    name: \"globalName\", // changed in v0.5 or so\n  }\n  for (let k of Object.keys(config)) {\n    if (!buildConfigKeys.has(k)) {\n      k = esbuildOptionKeyMap[k] || k  // possibly renamed\n      esbuildOptions[k] = config[k]\n    }\n  }\n  return esbuildOptions\n}\n\n\n// build wraps the \"real\" build function build1.\n// build does the following:\n// - makes a mutable copy of config\n// - wraps build1 in a CancellablePromise\n//\nfunction build(config /* BuildConfig */) {\n  config = config ? {...config} : {}  // copy we can mess with it\n  Object.defineProperty(config, CANCELED, { value: false, writable: true })\n\n  const resolver = { resolve(){}, reject(){} }\n  const cancelCallbacks = []\n\n  // (f :()=>void) :void\n  function addCancelCallback(f) {\n    if (config[CANCELED]) {\n      f()\n    } else {\n      cancelCallbacks.push(f)\n    }\n  }\n\n  function cancel(reason) {\n    if (!config[CANCELED]) {\n      log.debug(`build cancelled`, {reason})\n      config[CANCELED] = true\n      for (let f of cancelCallbacks) {\n        f && f()\n      }\n      cancelCallbacks.length = 0\n      if (reason) {\n        resolver.reject(reason)\n      } else {\n        resolver.resolve()\n      }\n    }\n  }\n\n  const p = cli_ready.then(() => new Promise((resolve, reject) => {\n    if (config[CANCELED]) {\n      log.debug(`build cancelled immediately`)\n      return false\n    }\n    resolver.resolve = resolve\n    resolver.reject = reject\n    build1(config, addCancelCallback).then(result => {\n      log.debug(`build1 finished`, {result, \"config[CANCELED]\":config[CANCELED]})\n      return resolve(result)\n    }).catch(reject)\n  }))\n\n  p.cancel = cancel\n  return p\n}\n\n\n// build1 is the \"real\" build function -- build() wraps it with cancellation.\nasync function build1(config, addCancelCallback) {\n  const isMainCall = IS_MAIN_CALL in config\n  delete config[IS_MAIN_CALL]\n\n  let opts = cliopts, args = cliargs\n\n  if (!isMainCall) {\n    // process config when build is called as a function\n    processConfig(config)\n  } else {\n    // special logic for when running this script directly as a program\n    if (args.length == 0) {\n      // no <srcfile>'s provided -- try to read tsconfig file in current directory\n      args.splice(args.length-1, 0, ...guessEntryPoints(config))\n      const tsconfig = getTSConfigForConfig(config)\n      if (!opts.outfile && !opts.outdir && tsconfig) {\n        opts.outfile = tsconfig.outFile\n        if (!opts.outfile) { opts.outdir = tsconfig.outDir }\n      }\n      if (args.length == 0) {\n        log.error(`missing <srcfile> argument`)\n        return false\n      }\n    }\n    config.entryPoints = args\n    config.outfile = opts.outfile || undefined\n    config.outdir = opts.outdir || undefined\n    config.bundle = opts.bundle || undefined\n    config.minify = opts.minify || undefined\n    config.cwd = process.cwd()\n    if (opts.esbuild) {\n      const esbuildProps = jsonparse(opts.esbuild, \"-esbuild\")\n      if (!esbuildProps || typeof esbuildProps != \"object\") {\n        log.error(\n          `-esbuild needs a JS object, for example '{key:\"value\"}'. Got ${typeof esbuildProps}.`\n        )\n        return false\n      }\n      log.debug(()=>`applying custom esbuild config ${repr(esbuildProps)}`)\n      for (let k in esbuildProps) {\n        config[k] = esbuildProps[k]\n      }\n    }\n  } // isMainCall\n\n  // smash config options and CLI options together\n  const watch = config.watch = opts.watch = !!(opts.watch || config.watch)\n  const debug = config.debug = opts.debug = !!(opts.debug || config.debug)\n  const quiet = config.quiet = opts.quiet = !!(opts.quiet || config.quiet)\n\n  if (config.color !== undefined) {\n    // update ANSI color setting\n    log.colorMode = config.color\n    style.reconfigure(process.stdout, config.color)\n    stderrStyle.reconfigure(process.stderr, config.color)\n  }\n\n  if (quiet) {\n    log.level = log.WARN\n  }\n\n  const onlyDiagnostics = !!opts.diag\n\n  let tscMode = opts[\"no-diag\"] ? \"off\" : onlyDiagnostics ? \"on\" : \"auto\" // \"on\" | \"off\" | \"auto\"\n  if (config.tsc !== undefined && config.tsc !== \"auto\") {\n    tscMode = (config.tsc && config.tsc != \"off\") ? \"on\" : \"off\"\n  }\n\n  if (onlyDiagnostics && tscMode == \"off\") {\n    log.error(\n      `invalid configuration: diagnostics are disabled but only disagnostics was requested.`\n    )\n    setErrorExitCode(1)\n    return false\n  }\n\n  const sourcemap = (\n    opts[\"inline-sourcemap\"] ? \"inline\" :\n    opts.sourcemap ? true :\n    config.sourcemap\n  )\n\n  config.clear = (\n    opts[\"no-clear\"] ? false :\n    config.clear === undefined ? !!process.stdout.isTTY :\n    config.clear\n  )\n\n  const workingDirectory = (\n    config.cwd ? Path.resolve(config.cwd) :\n    process.mainModule && dirname(process.mainModule.filename) || __dirname\n  )\n  if (workingDirectory != process.cwd()) {\n    let wd = Path.relative(process.cwd(), workingDirectory)\n    if (wd.startsWith(\"..\" + Path.sep)) {\n      wd = workingDirectory\n    }\n    log.debug(`Changing working directory to ${wd}`)\n  }\n  config.cwd = workingDirectory\n\n  if (!config.title) {\n    config.title = config.name || tildePath(config.cwd)\n  }\n\n\n  // Configure \"run\"\n  if (config.run) {\n    run.configure(config)\n  }\n\n\n  let lastClearTime = 0\n  function clear() {\n    screen.clear()\n    lastClearTime = clock()\n  }\n\n\n  let onStart = config.onStart || (()=>{})\n\n  let onEnd = (\n    config.onEnd ? (props, defaultReturn) => {\n      const r = config.onEnd(config, props)\n      const thenfn = r => r === undefined ? defaultReturn : r\n      return r instanceof Promise ? r.then(thenfn) : thenfn()\n    } : (props, defaultReturn) => {\n      logErrors( (props && props.errors) ? props.errors : [] )\n      return defaultReturn\n    }\n  )\n\n  if (config.outfileMode) {\n    let onEndInner = onEnd\n    onEnd = (props, defaultReturn) => {\n      try {\n        file.chmod(config.outfile, config.outfileMode)\n      } catch (err) {\n        log.error(\"configuration error: outfileMode: \" + err.message)\n        setErrorExitCode(1)\n      }\n      return onEndInner(props, defaultReturn)\n    }\n  }\n\n  // definitions\n  let define = {\n    DEBUG: debug,\n    ...(config.define || {})\n  }\n  for (let k in define) {\n    define[k] = json(define[k])\n  }\n\n  // options to esbuild\n  const esbuildOptions = {\n    // entryPoints: config.entryPoints,\n    minify: !debug,\n    sourcemap,\n    color: stderrStyle.ncolors > 0,\n\n    ...esbuildOptionsFromConfig(config),\n\n    define,\n  }\n\n\n  function onBuildSuccess(timeStart, { warnings }) {\n    logWarnings(warnings || [])\n    const outfile = config.outfile\n    if (!outfile) {\n      // show esbuild message when writing multiple files (outdir is set)\n      log.info(style.green(`Wrote to ${config.outdir}`))\n    } else {\n      const time = fmtDuration(clock() - timeStart)\n      let outname = outfile\n      if (sourcemap && sourcemap != \"inline\") {\n        const ext = Path.extname(outfile)\n        const name = Path.join(Path.dirname(outfile), Path.basename(outfile, ext))\n        outname = `${name}.{${ext.substr(1)},${ext.substr(1)}.map}`\n      }\n      let size = 0\n      try { size = fs.statSync(outfile).size } catch(_) {}\n      log.info(style.green(`Wrote ${outname}`) + ` (${fmtByteSize(size)}, ${time})`)\n    }\n    return onEnd({ warnings, errors: [] }, true)\n  }\n\n  function onBuildFail(timeStart, err) {\n    let warnings = err.warnings || []\n    let errors = err.errors || []\n    if (errors.length == 0) {\n      // this seems to be a bug in esbuild; errors are not set even when there are errors.\n      errors.push({\n        text: String(err),\n        location: null,\n      })\n    }\n    // if (/^error: must provide/i.test(stderr)) {\n    //   // unrecoverable error in configuration\n    //   if (!config) { process.exit(1) }\n    // }\n    logWarnings(warnings)\n    return onEnd({ warnings, errors }, false)\n  }\n\n  // build function\n  async function _esbuild(changedFiles /*:string[]*/) {\n    if (watch && config.clear) {\n      clear()\n    }\n\n    const r = onStart(config, changedFiles)\n    if (r instanceof Promise) {\n      await r\n    }\n    if (config[CANCELED]) {\n      return\n    }\n\n    log.debug(()=>\n      `invoking esbuild.build() in ${process.cwd()} with options: ` +\n      `${repr(esbuildOptions)}`\n    )\n\n    // wrap call to esbuild.build in a temporarily-changed working directory.\n    // TODO: When/if esbuild adds an option to set cwd, use that instead.\n    const tmpcwd = process.cwd()\n    process.chdir(workingDirectory)\n    const esbuildPromise = esbuild.build(esbuildOptions)\n    process.chdir(tmpcwd)\n\n    return esbuildPromise.then(\n      onBuildSuccess.bind(null, clock()),\n      onBuildFail.bind(null, clock()),\n    )\n  }\n\n  // start initial build\n  const buildPromise = opts.diag ? Promise.resolve() : _esbuild([])\n\n  // TypeScript linter\n  let tslintProcess = null\n  let tslintProcessReused = false\n  if (tscMode != \"off\") {\n    // Note: Wrapping this in memoize() makes it so that multiple identical tslint invocations\n    // are performed just once and share one promise.\n    const clearScreen = watch && opts.diag && config.clear\n    tslintProcess = memoize(tslint)({\n      watch,\n      quiet,\n      clearScreen,\n      colors: style.ncolors > 0,\n      cwd: workingDirectory,\n      mode: tscMode,\n      srcdir: dirname(config.entryPoints[0]),\n      rules: config.tsrules, // ok if undef\n      tsconfigFile: getTSConfigFileForConfig(config),\n      onRestart() {\n        // called when tsc begin to deliver a new session of diagnostic messages.\n        if (config.clear && clock() - lastClearTime > 5000) {\n          // it has been a long time since we cleared the screen.\n          // tsc likely reloaded the tsconfig.\n          screen.clear()\n        }\n      }\n    })\n    tslintProcessReused = isMemoized in tslintProcess\n    if (opts.diag) {\n      if (clearScreen) {\n        screen.clear()\n      }\n      return tslintProcess\n    }\n    if (!tslintProcessReused) {\n      // must add error handler now before `await buildPromise``\n      tslintProcess.catch(e => {\n        log.error(e.stack || String(e))\n        return false\n      })\n      addCancelCallback(() => { tslintProcess.cancel() })\n    }\n  }\n\n  // await build\n  let ok = await buildPromise\n  if (config[CANCELED]) {\n    return false\n  }\n\n  // unless watch mode, finish\n  if (!watch) {\n    if (tslintProcess) {\n      let tscWaitTimer\n      if (!ok) {\n        tslintProcess.cancel()\n      } else {\n        if (!tslintProcessReused) {\n          tscWaitTimer = setTimeout(() =>\n            log.info(\"Waiting for TypeScript... (^C to skip)\"), 1000)\n        }\n        ok = await tslintProcess.catch(() => false) // error handled earlier\n      }\n      clearTimeout(tscWaitTimer)\n    }\n    if (!config[CANCELED] && !ok) { setErrorExitCode() }\n    return ok\n  }\n\n  // watch & rebuild\n  // TODO: centralize this so that multiple calls to build don't spin up multiple watchers\n  // on the same source code. That way we can also clear() properly, just once.\n  log.info(`Watching files for changes...`)\n  const srcdirs = Array.from(new Set(\n    config.entryPoints.map(fn => dirname(Path.resolve(Path.join(workingDirectory, fn))))\n  ))\n  log.debug(`watching dirs:`, srcdirs)\n  const watchOptions = {\n    cwd: workingDirectory,\n    ...(typeof watch == \"object\" ? watch : {}),\n  }\n  const watchPromise = fswatch(srcdirs, watchOptions, files => {\n    // filter out any output files to avoid a loop\n    files = files.filter(fn => {\n      if (fn == config.outfile) {\n        return false\n      }\n      if (config.outdir && dirname(fn) == config.outdir) {\n        return false\n      }\n      return true\n    })\n    if (files.length > 0) {\n      log.info(`${files.length} files changed: ${files.join(\", \")}`)\n      return _esbuild(files)\n    }\n  })\n  addCancelCallback(() => { watchPromise.cancel() })\n  return watchPromise\n}\n\n\nfunction logWarnings(warnings) {\n  if (warnings.length > 0) {\n    // TODO: include warnings[N].location\n    log.warn(\"[warn] \" + warnings.map(m => m.text).join(\"\\n\"))\n  }\n}\n\n\nfunction logErrors(errors) {\n  if (errors.length > 0) {\n    // TODO: include errors[N].location\n    log.error(errors.map(m => m.text).join(\"\\n\"))\n  }\n}\n\n\nfunction main() {\n  return build({[IS_MAIN_CALL]:1}).catch(e => {\n    console.error(stderrStyle.red(prog + \": \" + (e.stack || e)))\n    process.exit(1)\n  }).then(ok => {\n    process.exit(ok ? 0 : 1)\n  })\n}\n\n\n// ------------------------------------------------------------------------\n// parse CLI and dispatch main\n\nfunction postProcessCLIOpts() {\n  if (cliopts[\"no-color\"]) {\n    cliopts.color = false\n  }\n  if (cliopts[\"no-diag\"]) {\n    cliopts.diag = false\n  }\n\n  // update ANSI color setting\n  log.colorMode = cliopts.color\n  style.reconfigure(process.stdout, cliopts.color)\n  stderrStyle.reconfigure(process.stderr, cliopts.color)\n\n  if (cliopts.color !== undefined) {\n    // user explicitly asked to either turn on or off color\n    // const nocolor  = process.argv.includes(\"-no-color\") || process.argv.includes(\"--no-color\")\n    // const yescolor = process.argv.includes(\"-color\") || process.argv.includes(\"--color\")\n  }\n\n  // just print version and exit?\n  if (cliopts[\"estrella-version\"]) {\n    console.log(`estrella ${VERSION}${DEBUG ? \" (debug)\" : \"\"}`)\n    process.exit(0)\n  }\n\n  // update log.debug function\n  if (cliopts[\"estrella-debug\"]) {\n    log.level = log.DEBUG\n  }\n\n  log.debug(()=> `Parsed initial CLI arguments: ${repr({options:cliopts, args:cliargs},2)}`)\n}\n\nif (\n  module.id == \".\" ||\n  process.mainModule && basename(process.mainModule.filename||\"\")\n  == (DEBUG ? \"estrella.g.js\" : \"estrella.js\")\n) {\n  // Note: esbuild replaces the module object, so when running from a esbuild bundle,\n  // module.id is undefined.\n  ;[cliopts, cliargs] = cli.parseopt(process.argv.slice(2), CLI_DOC_STANDALONE)\n  postProcessCLIOpts()\n  main()\n  return\n}\n\n// parse CLI arguments\n// Note: cliopts and cliargs are special objects exported in the API.\n// Note: This is only invoked when estrella runs from a user script, not when run directly.\n;[cliopts, cliargs] = cli.parseopt(process.argv.slice(2),{\n  ...CLI_DOC,\n  unknownFlagAsArg: true,\n  help(flags, _cliopts, _cliargs) {\n    cli_ready = new Promise(resolve => {\n      process.nextTick(() => {\n        console.log(cli.fmtUsage(flags, CLI_DOC.usage, CLI_DOC.trailer))\n        process.exit(0)\n        resolve()\n      })\n    })\n  },\n})\npostProcessCLIOpts()\n// parse(...flags :cli.Flags[]) : [cli.Options, string[]]\ncliopts.parse = (...flags) => {\n  log.debug(() =>\n    `Parsing custom CLI arguments ${json(cliargs.join)} via cliopts.parse(` +\n    repr(flags) + \")\"\n  )\n\n  const optsAndArgs = cli.parseopt(cliargs, {\n    ...CLI_DOC,\n    flags: CLI_DOC.flags.concat(flags),\n  })\n\n  log.debug(()=>\n    `Parsed extra CLI arguments: ` +\n    json({options: optsAndArgs[0], args: optsAndArgs[1]}, 2)\n  )\n\n  return optsAndArgs\n}\n\n\nfunction legacy_watchdir(path, filter, options, cb) {\n  if (cb === undefined) {\n    if (options === undefined) {\n      // watchdir(path, cb)\n      cb = filter\n      options = {}\n    } else {\n      // watchdir(path, filter, cb)\n      cb = options\n      options = { ...options, filter }\n      if (options.recursive !== undefined) {\n        if (!options.recursive) {\n          options.depth = 0\n        }\n        delete options.recursive\n      }\n    }\n  }\n  return fswatch(path, options, cb)\n}\n\n\nfunction sha1(input, outputEncoding) {\n  return crypto.createHash('sha1').update(input).digest(outputEncoding)\n}\n\n\nlet _tsapiInstance = undefined\n\n\n// API\nmodule.exports = {\n  // data\n  version: VERSION,\n  prog,    // CLI program name\n  cliopts, // parsed command-line options\n  cliargs, // command-line arguments left after parsing options\n\n  // functions\n  dirname,   // from NodeJS's \"path\" module\n  basename,  // from NodeJS's \"path\" module\n  watch: fswatch,\n  watchdir: legacy_watchdir,\n  scandir,\n  tslint,\n  defaultTSRules,\n  termStyle,\n  stdoutStyle: style,\n  stderrStyle: stderrStyle,\n  chmod: file.chmod,\n  editFileMode: file.editMode,\n  fmtDuration,\n  tildePath,\n  findInPATH,\n  tsconfig: getTSConfigForConfig,\n  tsconfigFile: getTSConfigFileForConfig,\n  glob: glob.glob,\n  globmatch: glob.match,\n  file,\n  sha1,\n\n  // TypeScript API\n  get ts() {\n    if (_tsapiInstance === undefined) {\n      _tsapiInstance = tsapi.createTSAPI()\n    }\n    return _tsapiInstance\n  },\n\n  // ----------------------------------------------------------------------------\n  // main build function\n  // build(config :BuildConfig) :Promise<boolean>\n  build,\n}\n"],
  "mappings": "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",
  "names": []
}
