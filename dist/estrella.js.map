{
  "version": 3,
  "sources": ["src/util.js", "src/memoize.js", "src/termstyle.js", "src/chmod.js", "src/screen.js", "src/watch.js", "src/tslint.js", "src/estrella.js"],
  "sourcesContent": ["import * as fs from \"fs\"\nimport * as Path from \"path\"\nimport { performance } from \"perf_hooks\"\n\nexport const json = JSON.stringify\nexport const clock = () => performance.now()\n\n\nexport function fmtDuration(ms) {\n  return (\n    ms >= 59500 ? (ms/60000).toFixed(0) + \"min\" :\n    ms >= 999.5 ? (ms/1000).toFixed(1) + \"s\" :\n    ms.toFixed(2) + \"ms\"\n  )\n}\n\nexport function findInPATH(executableName) {\n  const testExeExtToo = process.platform.startsWith(\"win\") && !/\\.exe$/i.test(executableName)\n  for (let dir of (process.env.PATH || \"\").split(Path.delimiter)) {\n    let path = Path.join(Path.resolve(dir), executableName)\n    while (true) {\n      try {\n        let st = fs.statSync(path)\n        if (st.isSymbolicLink()) {\n          path = fs.realpathSync.native(path)\n          continue\n        } else if (st.isFile() && st.mode & fs.constants.X_OK) {\n          return path\n        }\n      } catch (_) {}\n      break\n    }\n  }\n  return null\n}\n\n\n// jsonparse parses \"relaxed\" JSON which can be in JavaScript format\nexport function jsonparse(jsonText, filename /*optional*/) {\n  return require(\"vm\").runInNewContext(\n    '(()=>(' + jsonText + '))()',\n    { /* sandbox */ },\n    { filename, displayErrors: true }\n  )\n}\n\nexport function jsonparseFile(filename) {\n  return jsonparse(fs.readFileSync(filename, \"utf8\"), filename)\n}\n\n\nlet homedir = null\n\nexport function tildePath(path) {\n  const s = Path.resolve(path)\n  if (!homedir) { homedir = require(\"os\").homedir() }\n  if (s.startsWith(homedir)) {\n    return \"~\" + s.substr(homedir.length)\n  }\n  return s\n}\n", "import { json } from \"./util\"\n\nconst memoizeMap = new Map()\n\nexport const isMemoized = Symbol(\"isMemoized\")\n\nexport function memoize(fn) {\n  return function memoizedCall(...args) {\n    let k = args.map(json).join(\"\\0\")\n    if (!memoizeMap.has(k)) {\n      const result = fn(...args)\n      memoizeMap.set(k, result)\n      return result\n    }\n    let v = memoizeMap.get(k)\n    if (v && typeof v == \"object\") {\n      v[isMemoized] = true\n    }\n    return v\n  }\n}\n", "// terminal ANSI styling\nexport function termStyle(wstream, hint /* :bool|undefined */) {\n  let ncolors = 0\n  if (hint == true) {\n    // use colors regardless of TTY or not\n    let t = process.env.TERM || \"\"\n    ncolors = (\n      t && ['xterm','screen','vt100'].some(s => t.indexOf(s) != -1) ? (\n        t.indexOf('256color') != -1 ? 8 : 4\n      ) : 2\n    )\n  } else if (hint !== false && wstream.isTTY) {\n    // unless hint is explicitly false, use colors if stdout is a TTY\n    ncolors = wstream.getColorDepth()\n  }\n  const sfn = (\n    ncolors >= 8 ? (open16, open256, close) => {\n      let a = '\\x1b[' + open256 + 'm', b = '\\x1b[' + close + 'm'\n      return s => a + s + b\n    } :\n    ncolors > 0 ? (open16, open256, close) => {\n      let a = '\\x1b[' + open16 + 'm', b = '\\x1b[' + close + 'm'\n      return s => a + s + b\n    } :\n    () => s => s\n  )\n  return {\n    ncolors,\n    reset: \"\\e[0m\",\n    // name           16c    256c                 close\n    bold        : sfn('1',   '1',                 '22'),\n    italic      : sfn('3',   '3',                 '23'),\n    underline   : sfn('4',   '4',                 '24'),\n    inverse     : sfn('7',   '7',                 '27'),\n    white       : sfn('37',  '38;2;255;255;255',  '39'),\n    grey        : sfn('90',  '38;5;244',          '39'),\n    black       : sfn('30',  '38;5;16',           '39'),\n    blue        : sfn('34',  '38;5;75',           '39'),\n    cyan        : sfn('36',  '38;5;87',           '39'),\n    green       : sfn('32',  '38;5;84',           '39'),\n    magenta     : sfn('35',  '38;5;213',          '39'),\n    purple      : sfn('35',  '38;5;141',          '39'),\n    pink        : sfn('35',  '38;5;211',          '39'),\n    red         : sfn('31',  '38;2;255;110;80',   '39'),\n    yellow      : sfn('33',  '38;5;227',          '39'),\n    lightyellow : sfn('93',  '38;5;229',          '39'),\n    orange      : sfn('33',  '38;5;215',          '39'),\n  }\n}\n\nexport let style = termStyle(process.stdout)\nexport let stderrStyle = termStyle(process.stderr)\n", "import * as fs from \"fs\"\nimport { json } from \"./util\"\n\nconst fsconstants = fs.constants\n\nconst MOD_IRU = fsconstants.S_IRUSR,\n      MOD_IWU = fsconstants.S_IWUSR,\n      MOD_IXU = fsconstants.S_IXUSR,\n      MOD_IRG = fsconstants.S_IRGRP,\n      MOD_IWG = fsconstants.S_IWGRP,\n      MOD_IXG = fsconstants.S_IXGRP,\n      MOD_IRO = fsconstants.S_IROTH,\n      MOD_IWO = fsconstants.S_IWOTH,\n      MOD_IXO = fsconstants.S_IXOTH;\n\nconst chr = String.fromCharCode\nconst ord = (s, offs) => s.charCodeAt(offs || 0)\n\n\nexport function chmod(file, modifier) {\n  if (typeof modifier == \"number\") {\n    fs.chmodSync(file, modifier)\n    return modifier\n  }\n  let mode = fs.statSync(file).mode\n  let newMode = editFileMode(mode, modifier)\n  if (mode != newMode) {\n    fs.chmodSync(file, newMode)\n  }\n  return newMode\n}\n\n\nexport function editFileMode(mode, modifier) {\n  const expectedFormat = `Expected format: [ugoa]*[+-=][rwx]+`\n  const err = (msg, m) => new Error(`${msg} in modifier ${json(m)}. ${expectedFormat}`)\n  let mods = []\n  for (let m of Array.isArray(modifier) ? modifier : [ modifier ]) {\n    mods = mods.concat(m.trim().split(/\\s*,+\\s*/))\n  }\n  for (let m of mods) {\n    let who = []\n    let all = false\n    let op = 0\n    let perm = 0\n\n    for (let i = 0; i < m.length; i++) {\n      let c = ord(m, i)\n      if (op == 0) {\n        switch (c) {\n          case 0x75: // u\n          case 0x67: // g\n          case 0x6F: // o\n            if (!all) {\n              who.push(c)\n            }\n            break\n          case 0x61: // a\n            who = [ 0x75, 0x67, 0x6F ]\n            all = true\n            break\n          case 0x2B: // +\n          case 0x2D: // -\n          case 0x3D: // =\n            op = c\n            break\n          default:\n            if (op == 0) {\n              throw err(`Invalid target or operation ${json(chr(c))}`, m)\n            }\n            break\n        }\n      } else {\n        switch (c) {\n          case 0x72: perm |= 0o4 ; break // r\n          case 0x77: perm |= 0o2 ; break // w\n          case 0x78: perm |= 0o1 ; break // x\n          default: throw err(`Invalid permission ${json(chr(c))}`, m)\n        }\n      }\n    }\n    if (op == 0) {\n      throw err(`Missing operation`, m)\n    }\n    if (who.length == 0) {\n      who = [ 0x75 ] // u\n    }\n    if (perm == 0) {\n      perm = 0o4 | 0o2 | 0o1\n    }\n\n    let mode2 = 0\n    for (let w of who) {\n      switch (w) {\n        case 0x75: mode2 |= (perm << 6) ; break  // u\n        case 0x67: mode2 |= (perm << 3) ; break  // g\n        case 0x6F: mode2 |= perm        ; break  // o\n      }\n    }\n    switch (op) {\n      case 0x2B: mode |= mode2 ; break  // +\n      case 0x2D: mode &= ~mode2 ; break // -\n      case 0x3D: mode = mode2 ; break   // =\n    }\n    // For debugging:\n    // console.log({\n    //   who: who.map(n => '0o' + n.toString(8)),\n    //   op: String.fromCharCode(op),\n    //   perm: '0o' + perm.toString(8),\n    // })\n  } // for each m in modifier\n  return mode\n}\n\n\n// lil' unit test for editFileMode\nif (DEBUG) {\n  const asserteq = require(\"assert\").strictEqual\n  const oct = v => \"0o\" + v.toString(8).padStart(3, '0')\n  ;[// input, modifiers, expected\n    [ 0o444, [\"u+r\"],   0o444 ],\n    [ 0o444, [\"u+x\"],   0o544 ],\n    [ 0o444, [\"u+w\"],   0o644 ],\n    [ 0o444, [\"u+wx\"],  0o744 ],\n    [ 0o444, [\"u+rwx\"], 0o744 ],\n    [ 0o444, [\"u+r,u+w,u+x\"],    0o744 ],\n    [ 0o444, [\"u+r\", \"u+w,u+x\"], 0o744 ],\n    [ 0o444, [\"u+\"],    0o744 ], // no perm spec = all\n\n    [ 0o777, [\"u-r\"],   0o377 ],\n    [ 0o777, [\"u-wx\"],  0o477 ],\n    [ 0o777, [\"u-w\"],   0o577 ],\n    [ 0o777, [\"u-x\"],   0o677 ],\n    [ 0o777, [\"u-\"],    0o077 ],\n    [ 0o777, [\"u-rwx\"], 0o077 ],\n\n    [ 0o444, [\"g+r\"],   0o444 ],\n    [ 0o444, [\"g+x\"],   0o454 ],\n    [ 0o444, [\"g+w\"],   0o464 ],\n    [ 0o444, [\"g+wx\"],  0o474 ],\n    [ 0o444, [\"g+rwx\"], 0o474 ],\n    [ 0o444, [\"g+\"],    0o474 ],\n\n    [ 0o777, [\"g-r\"],   0o737 ],\n    [ 0o777, [\"g-wx\"],  0o747 ],\n    [ 0o777, [\"g-w\"],   0o757 ],\n    [ 0o777, [\"g-x\"],   0o767 ],\n    [ 0o777, [\"g-\"],    0o707 ],\n    [ 0o777, [\"g-rwx\"], 0o707 ],\n\n    [ 0o444, [\"o+r\"],   0o444 ],\n    [ 0o444, [\"o+x\"],   0o445 ],\n    [ 0o444, [\"o+w\"],   0o446 ],\n    [ 0o444, [\"o+wx\"],  0o447 ],\n    [ 0o444, [\"o+rwx\"], 0o447 ],\n    [ 0o444, [\"o+\"],    0o447 ],\n\n    [ 0o777, [\"o-r\"],   0o773 ],\n    [ 0o777, [\"o-wx\"],  0o774 ],\n    [ 0o777, [\"o-w\"],   0o775 ],\n    [ 0o777, [\"o-x\"],   0o776 ],\n    [ 0o777, [\"o-\"],    0o770 ],\n    [ 0o777, [\"o-rwx\"], 0o770 ],\n\n\n    [ 0o444, [\"ug+r\"],   0o444 ],\n    [ 0o444, [\"ug+x\"],   0o554 ],\n    [ 0o444, [\"ug+w\"],   0o664 ],\n    [ 0o444, [\"ug+wx\"],  0o774 ],\n    [ 0o444, [\"ug+rwx\"], 0o774 ],\n    [ 0o444, [\"ug+\"],    0o774 ],\n\n    [ 0o444, [\"ugo+r\"],   0o444 ],  [ 0o444, [\"a+r\"],   0o444 ],\n    [ 0o444, [\"ugo+x\"],   0o555 ],  [ 0o444, [\"a+x\"],   0o555 ],\n    [ 0o444, [\"ugo+w\"],   0o666 ],  [ 0o444, [\"a+w\"],   0o666 ],\n    [ 0o444, [\"ugo+wx\"],  0o777 ],  [ 0o444, [\"a+wx\"],  0o777 ],\n    [ 0o444, [\"ugo+rwx\"], 0o777 ],  [ 0o444, [\"a+rwx\"], 0o777 ],\n    [ 0o444, [\"ugo+\"],    0o777 ],  [ 0o444, [\"a+\"],    0o777 ],\n\n    [ 0o777, [\"ug-r\"],   0o337 ],\n    [ 0o777, [\"ug-wx\"],  0o447 ],\n    [ 0o777, [\"ug-w\"],   0o557 ],\n    [ 0o777, [\"ug-x\"],   0o667 ],\n    [ 0o777, [\"ug-\"],    0o007 ],\n    [ 0o777, [\"ug-rwx\"], 0o007 ],\n\n    [ 0o777, [\"ugo-r\"],   0o333 ],  [ 0o777, [\"a-r\"],   0o333 ],\n    [ 0o777, [\"ugo-wx\"],  0o444 ],  [ 0o777, [\"a-wx\"],  0o444 ],\n    [ 0o777, [\"ugo-w\"],   0o555 ],  [ 0o777, [\"a-w\"],   0o555 ],\n    [ 0o777, [\"ugo-x\"],   0o666 ],  [ 0o777, [\"a-x\"],   0o666 ],\n    [ 0o777, [\"ugo-\"],    0o000 ],  [ 0o777, [\"a-\"],    0o000 ],\n    [ 0o777, [\"ugo-rwx\"], 0o000 ],  [ 0o777, [\"a-rwx\"], 0o000 ],\n\n  ].map(([input, mods, expect]) => {\n    let actual = editFileMode(input, mods)\n    asserteq(actual, expect,\n      `editFileMode(${oct(input)}, ${json(mods)}) => ` +\n      `${oct(actual)} != expected ${oct(expect)}`\n    )\n  })\n} // end of editFileMode tests\n", "const stdoutIsTTY = !!process.stdout.isTTY\n    , stderrIsTTY = !!process.stderr.isTTY\n\nexport const screen = {\n  width: 60,\n  height: 20,\n  clear() {},\n  banner(ch) {\n    if (!ch) { ch = \"-\" }\n    return ch.repeat(Math.floor((screen.width - 1) / ch.length))\n  },\n}\n\nif (stdoutIsTTY || stderrIsTTY) {\n  const ws = (stdoutIsTTY && process.stdout) || process.stderr\n  const updateScreenSize = () => {\n    screen.width = ws.columns\n    screen.height = ws.rows\n  }\n  ws.on(\"resize\", updateScreenSize)\n  updateScreenSize()\n  screen.clear = () => {\n    // \"\\x1bc\" -- clear bottom\n    // \"\\x1b[2J\" -- clear top (leaves empty lines in backscroll in some cases)\n    ws.write(\"\\x1bc\")\n  }\n  // Note: we can clear past rows relatively using these two functions:\n  // ws.moveCursor(0, -4)\n  // ws.clearScreenDown()\n}\n", "import * as fs from \"fs\"\nimport * as Path from \"path\"\n\nexport function watchdir(dir, filter, options, cb) {\n  if (cb === undefined) {\n    if (options === undefined) {\n      // call form: watchdir(dir, cb)\n      cb = filter\n      filter = null\n    } else {\n      // call form: watchdir(dir, filter, cb)\n      cb = options\n      options = null\n    }\n  }\n  if (!options) { options = {} }\n  const latency = options.latency === undefined ? 100 : options.latency\n  const recursive = !!options.recursive\n  const changedFiles = new Set()\n  let timer = null\n  const onchange = (ev, file) => {\n    // console.log(\"fsevent\", ev, file)\n    if (filter && !filter.test(file)) {\n      return  // ignored by filter\n    }\n    changedFiles.add(file)\n    if (timer === null) {\n      timer = setTimeout(()=>{\n        timer = null\n        cb(Array.from(changedFiles))\n        changedFiles.clear()\n      }, latency)\n    }\n  }\n  let watchers = (Array.isArray(dir) ? dir : [dir]).map(dir =>\n    fs.watch(dir, { recursive }, onchange)\n  )\n  let stopped = false\n  const stop = () => {\n    clearTimeout(timer)\n    if (!stopped) {\n      stopped = true\n      watchers.map(w => w.close())\n    }\n  }\n  return stop\n}\n\n\n// scandir(\n//   dir      :string|string[],\n//   filter?  :RegExp|null,\n//   options? :WatchOptions|null,\n// ) :Promise<string[]>\nexport async function scandir(dir, filter, options) {\n  if (!options) { options = {} }\n  if (!fs.promises || !fs.promises.opendir) {\n    // opendir was added in node 12.12.0\n    throw new Error(`not implemented for nodejs <12.12.0`) // TODO\n  }\n  const files = []\n  const basedir = dir\n  const visited = new Set()\n  async function visit(dir, reldir) {\n    if (visited.has(dir)) {\n      // cycle\n      return\n    }\n    visited.add(dir)\n    const d = await fs.promises.opendir(dir)\n    // Note: d.close() is called implicitly by the iterator/generator\n    for await (const ent of d) {\n      let name = ent.name\n      if (ent.isDirectory()) {\n        if (options.recursive) {\n          await visit(Path.join(dir, name), Path.join(reldir, name))\n        }\n      } else if (ent.isFile() || ent.isSymbolicLink()) {\n        if (filter && filter.test(name)) {\n          files.push(Path.join(reldir, name))\n        }\n      }\n    }\n  }\n  return visit(Path.resolve(dir), \".\").then(() => files.sort())\n}\n", "import * as Path from \"path\"\nimport * as fs from \"fs\"\n\nimport { json, findInPATH } from \"./util\"\nimport { style, stderrStyle } from \"./termstyle\"\nimport { screen } from \"./screen\"\n\nconst { dirname, basename } = Path\n\n\n// defaultTSRules maps TS diagnostics codes to severity levels.\n// The special value IGNORE can be used to completely silence a diagnostic.\n// For diagnostic codes not listed, the default DiagnosticCategory for a\n// certain diagnostic is used.\nexport const defaultTSRules = {\n  6031: \"IGNORE\",  // starting compilation\n  6194: \"IGNORE\",  // Found N errors. Watching for file changes.\n  6133: \"WARNING\", // unused variable, parameter or import\n  2531: \"WARNING\", // Object is possibly 'null'\n  7006: \"WARNING\", // Parameter 'x' implicitly has an 'any' type.\n  7015: \"WARNING\", // Element implicitly has an 'any' type because index expression is not ...\n  7053: \"WARNING\", // Element implicitly has an 'any' type because expression of type can't be ...\n}\n\n\nfunction findTSC(cwd) {\n  let npmPath = \"\"\n  let tmpcwd = process.cwd()\n  if (cwd) { process.chdir(cwd) }\n  try {\n    npmPath = require.resolve(\"typescript\")\n  } catch (_) {\n  } finally {\n    if (cwd) { process.chdir(tmpcwd) }\n  }\n  if (npmPath) {\n    const find = Path.sep + \"node_modules\" + Path.sep\n    let i = npmPath.indexOf(find)\n    if (i != -1) {\n      return Path.join(npmPath.substr(0, i + find.length - Path.sep.length), \".bin\", \"tsc\")\n    }\n  }\n  // not found in node_modules\n  return \"tsc\"\n}\n\n\nexport function findTSConfigFile(dir) {\n  // start at dir and search for dir + tsconfig.json,\n  // moving to the parent dir until found or until parent dir is the root dir.\n  dir = Path.resolve(dir)\n  const root = Path.parse(dir).root\n  while (true) {\n    let path = Path.join(dir, \"tsconfig.json\")\n    if (fs.existsSync(path)) {\n      return path\n    }\n    dir = dirname(dir)\n    if (dir == root) {\n      // don't search \"/\"\n      break\n    }\n  }\n  return null\n}\n\n\nconst IGNORE  = 0\n    , INFO    = 1\n    , WARNING = 2\n    , ERROR   = 3\n\n\nconst severities = {IGNORE,INFO,WARNING,ERROR}\n\n\nfunction addTSRules(dst, src) {\n  for (let k of Object.keys(src)) {\n    let v = severities[String(src[k]).toUpperCase()]\n    if (v === undefined) {\n      throw new Error(\n        `Invalid value for TS rule ${k}: ${json(v)} -- expected value to be one of: `+\n        Object.keys(severities).map(json).join(\", \")\n      )\n    }\n    dst[k] = v\n  }\n}\n\n\n// returns a promise which resolves to a boolean \"no errors\", when the TSC process ends.\n// Note that in watch mode, the promise only resolves after explicitly calling cancel.\n// The returned promise is cancellable. I.e. p.cancel()\n//\nexport function tslint(options /*:TSLintOptions*/) {\n  if (!options) { options = {} }\n  let cancellation = {\n    cancelled: false,\n    cancel(){},\n  }\n  let p = new Promise((resolve, reject) => {\n\n  if (options.mode == \"off\") {\n    return resolve(true)\n  }\n\n  const logInfo = options.quiet ? ()=>{} : console.log.bind(console)\n  const cwd = options.cwd || process.cwd()\n\n  // find tsconfig.json file\n  const tsconfigFile = (\n    options.mode == \"on\" ? null :\n    findTSConfigFile(options.srcdir ? Path.resolve(cwd, options.srcdir) : cwd)\n  )\n  if (options.mode != \"on\" && !tsconfigFile) {\n    // no tsconfig file found -- in auto mode, we consider this \"not a TypeScript project\".\n    return resolve(true)\n  }\n\n  // find tsc program\n  let tscprog = findTSC(options.cwd /* ok if undefined */)\n  if (tscprog == \"tsc\" && options.mode != \"on\") {\n    // look up tsc in PATH\n    if (!(tscprog = findInPATH(tscprog))) {\n      // we found a tsconfig.json file but not tsc\n      console.warn(\n        stderrStyle.orange(prog + \":\") + ` tsc not found in node_modules or PATH.` +\n        ` However a tsconfig.json file was found in ` +\n        Path.relative(process.cwd(), dirname(tsconfigFile)) + `.`\n        ` Set tslint options.tsc=\"off\" or pass -no-diag on the command line.`\n      )\n      return resolve(true)\n    }\n  }\n\n  // rules\n  const tsrules = {}\n  addTSRules(tsrules, defaultTSRules)\n  if (options.rules) {\n    addTSRules(tsrules, options.rules)\n  }\n\n  // CLI arguments\n  let args = [\n    \"--noEmit\",\n    options.colors && \"--pretty\",\n    options.watch && \"--watch\",\n  ].concat(options.args || []).filter(a => a)\n\n  // spawn tsc process\n  const { spawn } = require(\"child_process\")\n  const p = spawn(tscprog, args, {\n    stdio: ['inherit', 'pipe', 'inherit'],\n    cwd,\n  })\n\n  // kill process on exit to avoid EPIPE errors\n  const onProcessExitHandler = () => {\n    try { p.kill() } catch (_) {}\n  }\n  process.on('exit', onProcessExitHandler)\n\n  // cancellation handler\n  cancellation.cancel = () => {\n    // called just once (guarded by user cancel function)\n    p.kill()\n  }\n\n  const infoStyle  = s => s\n      , warnStyle  = style.orange\n      , errorStyle = style.red\n      , okStyle    = style.green\n\n  const _TS_buf = Buffer.from(\" TS\")\n  const Found__buf = Buffer.from(\"Found \")\n  const ANSI_clear_buf = Buffer.from(\"\\x1bc\")\n  const Starting_compilation_buf = Buffer.from(\"Starting compilation\")\n\n  const tsmsgbuf = []\n  let tscode = 0\n  let lastRunHadErrors = false\n  let stats = {\n    errors: 0,\n    warnings: 0,\n    other: 0,\n    reset() {\n      this.errors = 0\n      this.warnings = 0\n      this.other = 0\n    },\n  }\n\n  let isIdle = false\n\n\n  function onSessionEnd() {\n    if (!options.quiet || stats.errors >= 0) {\n      options.watch && console.log(screen.banner(\"\u2014\"))\n      let summary = []\n      if (stats.errors > 0) {\n        summary.push(errorStyle(\"TS: \" + plural(`$ error`, `$ errors`, stats.errors)))\n      } else {\n        summary.push(okStyle(\"TS: OK\"))\n      }\n      if (stats.warnings > 0) {\n        summary.push(warnStyle(plural(`$ warning`, `$ warnings`, stats.warnings)))\n      }\n      if (stats.other > 0) {\n        summary.push(plural(`$ message`, `$ messages`, stats.other))\n      }\n      console.log(summary.join(\"   \"))\n      options.watch && console.log(screen.banner(\"\u2014\"))\n    }\n    lastRunHadErrors = stats.errors > 0\n    options.onEnd && options.onEnd(stats)\n    stats.reset()\n    isIdle = true\n  }\n\n\n  // called when tsmsgbuf contains one or more lines of one TypeScript message.\n  function flushTSMessage(compilationPassCompleted) {\n    // console.log(`------------------- TS${tscode} ------------------`)\n    // reset buffer\n    const lines = tsmsgbuf.slice()\n    tsmsgbuf.length = 0\n\n    if (tscode == 0) {\n      const line0 = lines[0]\n      if (line0.includes(Starting_compilation_buf)) {\n        stats.reset()\n        // ignore \"Starting compilation [in watch mode...]\" message\n        return compilationPassCompleted && onSessionEnd()\n      } else if (lines.every(line => line.length <= 1)) {\n        // ignore empty message\n        return compilationPassCompleted && onSessionEnd()\n      }\n    } else {\n      const errorRe = /(?:\\x1b\\[\\d+m|)error(?:\\x1b\\[\\d+m|)/g\n      let line0 = lines.shift().toString(\"utf8\")\n      switch (tsrules[tscode]) {\n        case IGNORE: return compilationPassCompleted && onSessionEnd()\n\n        case INFO:\n          // rewrite potentially ANSI-colored first line \"error\"\n          line0 = line0.replace(errorRe, infoStyle(\"info\"))\n          restyleSrcLineWaves(lines, infoStyle)\n          stats.other++\n          break\n\n        case WARNING:\n          // rewrite potentially ANSI-colored first line \"error\"\n          line0 = line0.replace(errorRe, warnStyle(\"warning\"))\n          restyleSrcLineWaves(lines, warnStyle)\n          stats.warnings++\n          break\n\n        default: // ERROR or other\n          if (errorRe.test(line0)) {\n            stats.errors++\n          } else {\n            stats.other++\n          }\n          break\n      }\n      process.stdout.write(line0)\n    }\n\n    // write lines to stdout\n    lines.forEach(v => process.stdout.write(v))\n\n    compilationPassCompleted && onSessionEnd()\n  }\n\n\n  function restyleSrcLineWaves(lines, stylefn) {\n    for (let i = 1; i < lines.length; i++) {\n      let line = lines[i]\n      if (line.includes(0x7e)) { // ~\n        let s = line.toString(\"utf8\") // \"\\x1b[91m\"\n        s = s.replace(/\\x1b\\[\\d+m(\\s*~+)/g, stylefn(\"$1\"))\n        lines[i] = s  // ok to set string instead of Buffer\n      }\n    }\n  }\n\n\n  function plural(singular, plural, n) {\n    return (n == 1 ? singular : plural).replace(/\\$/g, n)\n  }\n\n  lineReader(p.stdout, (line, flush) => {\n    if (!options.clearScreen) {\n      line = stripANSIClearCode(line)\n    }\n    if (flush) {\n      if (line.length > 0) {\n        tsmsgbuf.push(line)\n      }\n      if (tsmsgbuf.length > 0) {\n        flushTSMessage()\n      }\n      return\n    }\n\n    if (isIdle && line.length > 1) {\n      // first non-empty line after isIdle state has been entered marks the start of\n      // a new session.\n      isIdle = false\n      options.onRestart && options.onRestart()\n    }\n\n    if (line.includes(Found__buf)) {\n      let s = stripANSICodesStr(line.toString(\"utf8\"))\n      if (/^(?:\\[[^\\]]+\\] |[\\d\\:PAM \\-]+|)Found \\d+ error/.test(s)) {\n        // TypeScript has completed a compilation pass\n        flushTSMessage(true)\n        tscode = 0\n        return // don't add this line to line buffer\n      } else {\n        flushTSMessage(false)\n      }\n      tscode = 0\n    } else {\n      // console.log(\"--> \" + line.subarray(0, line.length-1).toString(\"utf8\"))\n      if (line.includes(_TS_buf)) {\n        const s = line.toString(\"utf8\")\n        const m = /(?:\\x1b\\[\\d+m|)error(?:\\x1b\\[\\d+m\\x1b\\[\\d+m|) TS(\\d+)\\:/.exec(s)\n        // const m = /(?:\\x1b\\[\\d+m|)error(?:\\x1b\\[\\d+m|) TS(\\d+)\\:/.exec(s)\n        let tscode2 = m ? parseInt(m[1]) : 0\n        if (tscode2 > 0 && !isNaN(tscode2)) {\n          if (tsmsgbuf.length > 0) {\n            flushTSMessage()\n          }\n          tscode = tscode2\n        }\n      }\n    }\n    tsmsgbuf.push(line)\n  })\n\n  // lineReader(p.stderr, line => {\n  //   process.stderr.write(line)\n  // })\n\n  p.on('close', code => {\n    // console.log(`tsc exited with code ${code}`)\n    process.removeListener('exit', onProcessExitHandler)\n    resolve(!lastRunHadErrors)\n  })\n\n  function stripANSICodesStr(s) {\n    return s.replace(/\\x1b\\[\\d+m/g, \"\")\n  }\n\n  function stripANSIClearCode(buf) {\n    // strip \"clear\" ANSI code is present in buf\n    let i = buf.indexOf(ANSI_clear_buf)\n    return (\n      i == -1 ? buf :\n      i == 0 ? buf.subarray(3) :\n      Buffer.concat([buf.subarray(0,i), buf.subarray(i+3)], buf.length - 3)\n    )\n  }\n  }) // Promise\n  p.cancel = () => {\n    if (!cancellation.cancelled) {\n      cancellation.cancelled = true\n      cancellation.cancel()\n    }\n    return p\n  }\n  return p\n} // end function tslint\n\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\n\nfunction lineReader(r, onLine) {\n  let bufs = [], bufz = 0\n  const readbuf = data => {\n    let offs = 0\n    while (true) {\n      let i = data.indexOf(0x0A, offs)\n      if (i == -1) {\n        if (offs < data.length - 1) {\n          const chunk = data.subarray(offs)\n          bufs.push(chunk)\n          bufz += chunk.length\n        }\n        break\n      }\n      i++\n      let buf = data.subarray(offs, i)\n      if (bufz > 0) {\n        buf = Buffer.concat(bufs.concat(buf), bufz + buf.length)\n        bufs.length = 0\n        bufz = 0\n      }\n      onLine(buf, false)\n      offs = i\n    }\n  }\n  const flush = () => {\n    if (bufs.length > 0) {\n      onLine(Buffer.concat(bufs, bufz), true)\n    } else {\n      onLine(emptyBuffer, true)\n    }\n  }\n\n  // TEST\n  // readbuf(Buffer.from(\"hello\"))\n  // readbuf(Buffer.from(\" world\\n\"))\n  // readbuf(Buffer.from(\"How\"))\n  // readbuf(Buffer.from(\"'s \"))\n  // readbuf(Buffer.from(\"it go\"))\n  // readbuf(Buffer.from(\"ing?\\n\"))\n  // readbuf(Buffer.from(\"quite well\\nI hope!\\nBye\\n\"))\n  // readbuf(Buffer.from(\"bye.\"))\n  // flush()\n  // lineReader(0, line => {\n  //   console.log({line:line.toString(\"utf8\")})\n  // })\n\n  r.on(\"data\", readbuf)\n  r.on(\"close\", flush)\n  r.on(\"end\", flush)\n}\n", "#!/usr/bin/env node\nimport * as esbuild from \"esbuild\"\nimport * as fs from \"fs\"\nimport * as Path from \"path\"\n\nimport { json, clock, fmtDuration, findInPATH, tildePath } from \"./util\"\nimport { memoize, isMemoized } from \"./memoize\"\nimport { termStyle, style, stderrStyle } from \"./termstyle\"\nimport { chmod, editFileMode } from \"./chmod\"\nimport { screen } from \"./screen\"\nimport { scandir, watchdir } from \"./watch\"\nimport { tslint, defaultTSRules, findTSConfigFile } from \"./tslint\"\n\nconst { dirname, basename } = Path\n\nconst USAGE = `\nusage: $0 [options]\noptions:\n  -watch, -w          Watch source files for changes and rebuild.\n  -debug, -g          Do not optimize and define DEBUG=true.\n  -sourcemap          Generate sourcemap.\n  -inline-sourcemap   Generate inline sourcemap.\n  -color              Color terminal output, regardless of TTY status.\n  -no-color           Disable use of colors.\n  -no-clear           Disable clearing of the screen, regardless of TTY status.\n  -no-diag            Disable TypeScript diagnostics.\n  -diag               Only run TypeScript diagnostics (no esbuild.)\n  -quiet              Only log warnings and errors but nothing else.\n  -h, -help           Print help to stderr and exit 0.\n  -estrella-version   Print version of estrella and exit 0.\n  -estrella-debug     Enable debug logging of estrella itself.\n`\n\n// CLI options with their default values\nconst cliOptions = {\n  w: false, watch: false,\n  debug: false, g: false,\n  color: false,\n  \"no-color\": false,\n  sourcemap: false,\n  \"inline-sourcemap\": false,\n  \"no-clear\": false,\n  \"no-diag\": false,\n  diag: false,\n  quiet: false,\n  \"estrella-debug\": false,\n  \"estrella-version\": false,\n}\n\n// CLI options when run directly, not via a script\nconst maincli = {\n  helpUsage: \"usage: $0 [options] <srcfile> ...\",\n  helpExtraText: `\n  -bundle             Bundle all dependencies into the output files.\n  -minify             Simplify and compress generated code.\n  -o, -outfile <file> Write output to <file> instead of stdout.\n  -outdir <dir>       Write output to <dir> instead of stdout.\n  `,\n  extraOptions: {\n    bundle: false,\n    minify: false,\n    outdir: \"\",\n    outfile: \"\", o: \"\",\n  },\n}\n\n// keys of the config object passed to main/build which are specific to this program\n// and not accepted by esbuild.\n// Should match keys of BuildConfig struct in estrella.d.ts\nconst buildConfigKeys = new Set([\n  \"cwd\",\n  \"debug\",\n  \"entry\",\n  \"onEnd\",\n  \"onStart\",\n  \"outfileMode\",\n  \"quiet\",\n  \"title\",\n  \"tsc\",\n  \"tsrules\",\n  \"watch\",\n])\n\n// ---------------------------------------------------------------------------------------------\n\nconst prog = (process.env[\"_\"]||\"/node\").endsWith(\"/node\") ? process.argv[1] : process.env[\"_\"]\n\n\n// setErrorExitCode(code:number=1) causes the program to exit with the provied code\n// in case it exits cleanly.\n// This is used to make it possible to exit with an error when there are multiple\n// builds happening.\n//\nlet _setErrorExitCode = false\nfunction setErrorExitCode(code) {\n  if (!_setErrorExitCode) {\n    _setErrorExitCode = true\n    let overrideCode = code || 1\n    process.on(\"exit\", code => { process.exit(code || overrideCode) })\n  }\n}\n\n\nfunction processConfig(config) {\n  // support use of both entry and entryPoints\n  if (!config.entryPoints) {\n    config.entryPoints = []\n  }\n  if (config.entry) {\n    if (Array.isArray(config.entry)) {\n      config.entryPoints = config.entryPoints.concat(config.entry)\n    } else {\n      config.entryPoints.push(config.entry)\n    }\n  }\n  delete config.entry\n  if (config.entryPoints.length == 0) {\n    throw new Error(\"config.entryPoints is empty or not set\")\n  }\n  // here, config.entryPoints is always of type: string[]\n\n  // esbuild wants sourcemap option as a string and never as a bool.\n  if (config.sourcemap) {\n    if (config.sourcemap != \"inline\") {\n      config.sourcemap = \"external\"\n    }\n  } else {\n    delete config.sourcemap\n  }\n}\n\n\nfunction esbuildOptionsFromConfig(config) {\n  let esbuildOptions = {}\n  for (let k of Object.keys(config)) {\n    if (!buildConfigKeys.has(k)) {\n      esbuildOptions[k] = config[k]\n    }\n  }\n  return esbuildOptions\n}\n\n\nfunction usage(errmsg, extra) {\n  errmsg && console.error(`${prog}: ${errmsg}`)\n  let msg = USAGE.trim()\n  if (extra) {\n    if (extra.helpUsage) {\n      msg = extra.helpUsage + msg.substr(msg.indexOf(\"\\n\"))\n    }\n    if (extra.helpExtraText) {\n      msg += extra.helpExtraText\n    }\n  }\n  msg = msg.replace(/\\$0\\b/g, prog)\n  console.error(msg.trim())\n  process.exit(errmsg ? 1 : 0)\n}\n\n\n// parseopt<T>(opts1:T, args1:string[]) -> {opts:T,args:string[]}\nfunction parseopt(options, args, extra) {\n  if (extra) {\n    options = { ...options, ...extra.extraOptions }\n  }\n\n  const opts = { ...options }  // start with defaults\n  const seenCollections = new Set()\n  let restArgs = []\n  let i = 1\n\n  function eatarg(k, kv, verbatim) {\n    let v = options[k]\n    const t = typeof v\n    if (typeof v == \"boolean\") {\n      opts[k] = !v  // invert/negate the default value\n    } else {\n      const value = kv ? kv : args[++i]\n      if (value === undefined) {\n        usage(`missing value for option ${verbatim}`, extra)\n      }\n      if (Array.isArray(v)) {\n        ;(opts[k] || (opts[k] = [])).push(value)\n      } else {\n        opts[k] = value\n      }\n    }\n  }\n\n  for (; i < args.length; i++) {\n    let s = args[i]\n    if (s == \"--\") {\n      restArgs = restArgs.concat(args.slice(i + 1))  // +1 to exclude \"--\"\n      break\n    }\n    if (s.startsWith(\"-\") && s != \"-\") {\n      const [k,kv] = s.replace(/^\\-+/,\"\").split(\"=\")\n      if (k == \"h\" || k == \"help\") {\n        usage(null, extra)\n      }\n      if (!(k in options)) {\n        // support compact short options, e.g. -gw == -g -w\n        if (s[1] != \"-\" && !kv) { // starts with \"-\" (not \"--\") and does not have value\n          let l = k.split(\"\")\n          if (l.every(k => typeof options[k] == \"boolean\")) {\n            l.map(k => eatarg(k, \"\", s))\n            continue\n          }\n        }\n        usage(`unknown option ${s}`, extra)\n      }\n      eatarg(k, kv, s)\n    } else {\n      restArgs.push(s)\n    }\n  }\n  return { opts, args: restArgs }\n}\n\n\nconst IS_MAIN_CALL = Symbol(\"IS_MAIN_CALL\")\n\n\n\nasync function build(argv, config /* BuildConfig */) {\n  let isMainCall = false\n  if (config === IS_MAIN_CALL) {\n    config = {}\n    isMainCall = true\n    // { entryPoints: [\"\"] }\n  } else {\n    if (config) { config = {...config} } // copy, so we can mess with it\n    processConfig(config)\n  }\n\n  const { opts, args } = parseopt(cliOptions, argv, isMainCall ? maincli : null)\n\n  if (opts[\"estrella-version\"]) {\n    console.log(`estrella ${VERSION}${DEBUG ? \" (debug)\" : \"\"}`)\n    process.exit(0)\n  }\n\n  // special logic for when running this script directly as a program\n  if (isMainCall) {\n    if (args.length == 0) {\n      // no <srcfile>'s provided -- try to read tsconfig file in current directory\n      let tsconfig = null\n      try { tsconfig = jsonparseFile(findTSConfigFile(process.cwd())) } catch(_) {}\n      if (tsconfig) {\n        let files = tsconfig.files || tsconfig.include\n        if (files) {\n          if (!Array.isArray(files)) {\n            args.push(files)\n          } else for (let s of files) {\n            args.push(s)\n          }\n        }\n        if (!opts.outfile) { opts.outfile = tsconfig.outFile }\n        if (!opts.outfile) { opts.outdir = tsconfig.outDir }\n      }\n      if (args.length == 0) {\n        usage(`missing <srcfile> argument`, maincli)\n      }\n    }\n    config.entryPoints = args\n    config.outfile = opts.o || opts.outfile || undefined\n    config.outdir = opts.outdir || undefined\n    config.bundle = opts.bundle || undefined\n    config.minify = opts.minify || undefined\n    config.cwd = process.cwd()\n  }\n\n  const watch = config.watch = opts.watch = !!(opts.w || opts.watch || config.watch)\n  const debug = config.debug = opts.debug = !!(opts.debug || opts.g || config.debug)\n  const quiet = config.quiet = opts.quiet = !!(opts.quiet || config.quiet)\n\n  if (config.color !== undefined) {\n    if (config.color) {\n      opts.color = true\n    } else {\n      opts[\"no-color\"] = true\n    }\n  }\n\n  const colorHint = opts.color || (opts[\"no-color\"] ? false : undefined)\n  style = termStyle(process.stdout, colorHint)\n  stderrStyle = termStyle(process.stderr, colorHint)\n\n  const logError = (...args) => console.error(stderrStyle.red(`${prog}:`), ...args)\n  const logWarn  = console.log.bind(console)\n  const logInfo  = quiet ? ()=>{} : console.log.bind(console)\n  const logInfoOnce = quiet ? ()=>{} : memoize(logInfo)\n  const logDebug = opts[\"estrella-debug\"] ? f => {\n    let r = f() ; if (!Array.isArray(r)) { r = [r] }\n    console.error(stderrStyle.pink(\"[DEBUG]\"), ...r)\n  } : ()=>{}\n\n  const onlyDiagnostics = !!opts.diag\n\n  let tscMode = opts[\"no-diag\"] ? \"off\" : onlyDiagnostics ? \"on\" : \"auto\" // \"on\" | \"off\" | \"auto\"\n  if (config.tsc !== undefined && config.tsc !== \"auto\") {\n    tscMode = (config.tsc && config.tsc != \"off\") ? \"on\" : \"off\"\n  }\n\n  if (onlyDiagnostics && tscMode == \"off\") {\n    logError(\n      `invalid configuration: diagnostics are disabled but only disagnostics was requested.`\n    )\n    setErrorExitCode(1)\n    return false\n  }\n\n  const sourcemap = (\n    opts[\"inline-sourcemap\"] ? \"inline\" :\n    opts.sourcemap ? \"external\" :\n    config.sourcemap\n  )\n  if (!process.stdout.isTTY) {\n    opts[\"no-clear\"] = true\n  }\n\n  const workingDirectory = (\n    config.cwd ? Path.resolve(config.cwd) :\n    process.mainModule && dirname(process.mainModule.filename) || __dirname\n  )\n  if (workingDirectory != process.cwd()) {\n    let wd = Path.relative(process.cwd(), workingDirectory)\n    if (wd.startsWith(\"..\" + Path.sep)) {\n      wd = workingDirectory\n    }\n    logInfoOnce(`Changing working directory to ${wd}`)\n  }\n  config.cwd = workingDirectory\n\n  if (!config.title) {\n    config.title = config.name || tildePath(config.cwd)\n  }\n\n\n  let lastClearTime = 0\n  function clear() {\n    screen.clear()\n    lastClearTime = clock()\n  }\n\n\n  let onStart = config.onStart || (()=>{})\n\n\n  let onEnd = (\n    config.onEnd ? (props, defaultReturn) => {\n      const r = config.onEnd(config, props)\n      const thenfn = r => r === undefined ? defaultReturn : r\n      return r instanceof Promise ? r.then(thenfn) : thenfn()\n    } : (_, defaultReturn) => defaultReturn\n  )\n\n  if (config.outfileMode) {\n    let onEndInner = onEnd\n    onEnd = (props, defaultReturn) => {\n      try {\n        chmod(config.outfile, config.outfileMode)\n      } catch (err) {\n        logError(\"configuration error: outfileMode: \" + err.message)\n        setErrorExitCode(1)\n      }\n      return onEndInner(props, defaultReturn)\n    }\n  }\n\n\n  function onBuildSuccess(timeStart, { stderr, warnings }) {\n    logWarnings(warnings)\n    const outfile = config.outfile\n    if (!outfile) {\n      // show esbuild message when writing multiple files (outdir is set)\n      stderr = stderr.replace(/\\n$/, \"\")\n      stderr.length > 0 && logInfo(stderr)\n    } else {\n      const m = /\\(([^\\)]+)\\)\\n/.exec(stderr)\n      const time = fmtDuration(clock() - timeStart)\n      let outname = outfile\n      if (sourcemap == \"external\") {\n        const ext = Path.extname(outfile)\n        const name = Path.join(Path.dirname(outfile), Path.basename(outfile, ext))\n        outname = `${name}.{${ext.substr(1)},${ext.substr(1)}.map}`\n      }\n      logInfo(style.green(`Wrote ${outname}`) + ` (${m ? m[1] : \"?B\"}, ${time})`)\n    }\n    return onEnd({ warnings, errors: [] }, true)\n  }\n\n\n  function onBuildFail(timeStart, { stderr, warnings, errors }) {\n    logWarnings(warnings)\n    console.error(stderr)\n    if (errors.length == 0) {\n      // this seems to be a bug in esbuild; errors are not set even when there are errors.\n      errors.push({\n        text: stderr.trim(),\n        location: null,\n      })\n    }\n    if (/^error: must provide/i.test(stderr)) {\n      // unrecoverable error in configuration\n      if (!config) { process.exit(1) }\n    }\n    return onEnd({ warnings, errors }, false)\n  }\n\n  // definitions\n  let define = {\n    DEBUG: debug,\n    ...(config.define || {})\n  }\n  for (let k in define) {\n    define[k] = json(define[k])\n  }\n\n  // options to esbuild\n  const esbuildOptions = {\n    // entryPoints: config.entryPoints,\n    minify: !debug,\n    sourcemap,\n    color: stderrStyle.ncolors > 0,\n\n    ...esbuildOptionsFromConfig(config),\n\n    define,\n  }\n\n  // build function\n  async function build() {\n    if (watch && !opts[\"no-clear\"]) {\n      clear()\n    }\n\n    const r = onStart(config)\n    if (r instanceof Promise) {\n      await r\n    }\n\n    // wrap call to esbuild.build in a temporarily-changed working directory.\n    // TODO: When/if esbuild adds an option to set cwd, use that instead.\n    const tmpcwd = process.cwd()\n    process.chdir(workingDirectory)\n    const esbuildPromise = esbuild.build(esbuildOptions)\n    process.chdir(tmpcwd)\n\n    return esbuildPromise.then(\n      onBuildSuccess.bind(null, clock()),\n      onBuildFail.bind(null, clock()),\n    )\n  }\n\n  // start initial build\n  const buildPromise = opts.diag ? Promise.resolve() : build()\n\n  // TypeScript linter\n  let tslintProcess = null\n  let tslintProcessMemoized = false\n  if (tscMode != \"off\") {\n    // Note: Wrapping this in memoize() makes it so that multiple identical tslint invocations\n    // are performed just once and share one promise.\n    const clearScreen = watch && opts.diag && !opts[\"no-clear\"]\n    tslintProcess = memoize(tslint)({\n      watch,\n      quiet,\n      clearScreen,\n      colors: style.ncolors > 0,\n      cwd: workingDirectory,\n      mode: tscMode,\n      srcdir: dirname(config.entryPoints[0]),\n      rules: config.tsrules, // ok if undef\n      onRestart() {\n        // called when tsc begin to deliver a new session of diagnostic messages.\n        if (!opts[\"no-clear\"] && clock() - lastClearTime > 5000) {\n          // it has been a long time since we cleared the screen.\n          // tsc likely reloaded the tsconfig.\n          screen.clear()\n        }\n      }\n    })\n    tslintProcessMemoized = isMemoized in tslintProcess\n    if (opts.diag) {\n      if (clearScreen) {\n        screen.clear()\n      }\n      return tslintProcess\n    }\n    if (!tslintProcessMemoized) {\n      // must add error handler now before `await buildPromise``\n      tslintProcess.catch(e => {\n        logError(e.stack || String(e))\n        return false\n      })\n    }\n  }\n\n  // build\n  let ok = await buildPromise\n  if (!watch) {\n    if (tslintProcess) {\n      let tscWaitTimer\n      if (!ok) {\n        tslintProcess.cancel()\n      } else {\n        if (!tslintProcessMemoized) {\n          tscWaitTimer = setTimeout(() =>\n            logInfo(\"Waiting for TypeScript... (^C to skip)\"), 1000)\n        }\n        ok = await tslintProcess.catch(() => false) // error handled earlier\n      }\n      clearTimeout(tscWaitTimer)\n    }\n    if (config) {\n      if (!ok) { setErrorExitCode() }\n      return ok\n    } else {\n      process.exit(ok ? 0 : 1)\n    }\n  }\n\n  // watch & rebuild\n  // TODO: centralize this so that multiple calls to build don't spin up multiple watchers\n  // on the same source code. That way we can also clear() properly, just once.\n  logInfo(`Watching files for changes...`)\n  const srcdirs = Array.from(new Set(\n    config.entryPoints.map(fn => dirname(Path.resolve(Path.join(workingDirectory, fn))))\n  ))\n  logDebug(()=> [`watching dirs:`, srcdirs])\n  watchdir(srcdirs, /\\.[tj]s$/, { recursive: true }, files => {\n    logInfo(files.length + \" files changed:\", files.join(\", \"))\n    build()\n  })\n\n}\n\n\nfunction logWarnings(v) {\n  v.length > 0 && console.log(\"[warn] \" + v.map(m => m.text).join(\"\\n\"))\n}\n\n\nfunction main() {\n  return build(process.argv.slice(1), IS_MAIN_CALL).catch(e => {\n    console.error(stderrStyle.red(prog + \": \" + (e.stack || e)))\n    process.exit(1)\n  }).then(() => {\n    process.exit(0)\n  })\n}\n\n\nif (\n  module.id == \".\" ||\n  process.mainModule && basename(process.mainModule.filename||\"\")\n  == (DEBUG ? \"estrella.g.js\" : \"estrella.js\")\n) {\n  // Note: esbuild replaces the module object, so when running from a esbuild bundle,\n  // module.id is undefined.\n  main()\n  return\n}\n\n\n// special object exported in the API. Holds a copy of the last parseopt result,\nconst { opts:cliopts, args:cliargs } = parseopt(cliOptions, process.argv.slice(1))\n// alias spread\ncliopts.watch = !!(cliopts.watch || cliopts.w)\ncliopts.debug = !!(cliopts.debug || cliopts.g)\n\n\n// API\nmodule.exports = {\n  // data\n  prog,    // CLI program name\n  cliopts, // parsed command-line options\n  cliargs, // command-line arguments left after parsing options\n\n  // functions\n  dirname,   // from NodeJS's \"path\" module\n  basename,  // from NodeJS's \"path\" module\n  watchdir,\n  scandir,\n  tslint,\n  defaultTSRules,\n  termStyle,\n  chmod,\n  editFileMode,\n  fmtDuration,\n  tildePath,\n  findInPATH,\n  findTSConfigFile,\n\n  // main build function\n  // build(config :BuildConfig) :Promise<boolean>\n  build(config) {\n    return build(process.argv.slice(1), config).catch(e => {\n      console.error(stderrStyle.red(prog + \": \" + (e.stack || e)))\n      process.exit(1)\n    })\n  },\n}\n"],
  "mappings": ";oZAAA,8HAAoB,kBACpB,EAAsB,oBACtB,EAA4B,0BAErB,KAAM,GAAO,KAAK,UACZ,EAAQ,IAAM,cAAY,MAGhC,WAAqB,GAC1B,MACE,IAAM,MAAS,GAAG,OAAO,QAAQ,GAAK,MACtC,GAAM,MAAS,GAAG,MAAM,QAAQ,GAAK,IACrC,EAAG,QAAQ,GAAK,KAIb,WAAoB,GACzB,KAAM,GAAgB,QAAQ,SAAS,WAAW,QAAU,CAAC,UAAU,KAAK,GAC5E,OAAS,KAAQ,SAAQ,IAAI,MAAQ,IAAI,MAAM,cAC7C,GAAI,GAAO,OAAU,UAAa,GAAM,GACxC,QACE,IACE,GAAI,GAAK,WAAY,GACrB,GAAI,EAAG,kBACL,EAAO,eAAgB,OAAO,GAC9B,iBACS,EAAG,UAAY,EAAG,KAAO,YAAa,KAC/C,MAAO,SAEF,IACT,OAGJ,MAAO,MAKF,WAAmB,EAAU,GAClC,MAAO,cAAc,gBACnB,SAAW,EAAW,OACtB,GACA,UAAE,gBAAyB,KAIxB,WAAuB,GAC5B,MAAO,GAAU,eAAgB,EAAU,QAAS,GAItD,GAAI,GAAU,KAEP,WAAmB,GACxB,KAAM,GAAI,UAAa,GACvB,MAAK,IAAW,GAAU,cAAc,WACpC,EAAE,WAAW,GACR,IAAM,EAAE,OAAO,EAAQ,QAEzB,SC3DT,+CAAqB,MAErB,KAAM,GAAa,GAAI,OAEhB,KAAM,GAAa,OAAO,cAE1B,WAAiB,GACtB,MAAO,eAAyB,GAC9B,GAAI,GAAI,EAAK,IAAI,QAAM,KAAK,MAC5B,GAAI,CAAC,EAAW,IAAI,IAClB,KAAM,GAAS,EAAG,GAAG,GACrB,SAAW,IAAI,EAAG,GACX,EAET,GAAI,GAAI,EAAW,IAAI,GACvB,MAAI,IAAK,MAAO,IAAK,UACnB,GAAE,GAAc,IAEX,UClBX,sDACO,WAAmB,EAAS,GACjC,GAAI,GAAU,EACd,GAAI,GAAQ,IAEV,GAAI,GAAI,QAAQ,IAAI,MAAQ,GAC5B,EACE,GAAK,CAAC,QAAQ,SAAS,SAAS,KAAK,GAAK,EAAE,QAAQ,IAAM,IACxD,EAAE,QAAQ,aAAe,GAAK,EAAI,EAChC,MAED,AAAI,KAAS,IAAS,EAAQ,OAEnC,GAAU,EAAQ,iBAEpB,KAAM,GACJ,GAAW,EAAI,CAAC,EAAQ,EAAS,KAC/B,GAAI,GAAI,KAAU,EAAU,IAAK,EAAI,KAAU,EAAQ,IACvD,MAAO,IAAK,EAAI,EAAI,GAEtB,EAAU,EAAI,CAAC,EAAQ,EAAS,KAC9B,GAAI,GAAI,KAAU,EAAS,IAAK,EAAI,KAAU,EAAQ,IACtD,MAAO,IAAK,EAAI,EAAI,GAEtB,IAAM,GAAK,EAEb,MAAO,SACL,QACO,YAEO,EAAI,IAAO,IAAqB,aAChC,EAAI,IAAO,IAAqB,gBAChC,EAAI,IAAO,IAAqB,cAChC,EAAI,IAAO,IAAqB,YAChC,EAAI,KAAO,mBAAqB,WAChC,EAAI,KAAO,WAAqB,YAChC,EAAI,KAAO,UAAqB,WAChC,EAAI,KAAO,UAAqB,WAChC,EAAI,KAAO,UAAqB,YAChC,EAAI,KAAO,UAAqB,cAChC,EAAI,KAAO,WAAqB,aAChC,EAAI,KAAO,WAAqB,WAChC,EAAI,KAAO,WAAqB,UAChC,EAAI,KAAO,kBAAqB,aAChC,EAAI,KAAO,WAAqB,kBAChC,EAAI,KAAO,WAAqB,aAChC,EAAI,KAAO,WAAqB,OAI3C,GAAI,GAAQ,EAAU,QAAQ,QAC1B,EAAc,EAAU,QAAQ,eCnD3C,+CAAoB,kBACpB,EAAqB,MAErB,KAAM,GAAc,YAEd,EAAU,EAAY,QACtB,EAAU,EAAY,QACtB,EAAU,EAAY,QACtB,EAAU,EAAY,QACtB,EAAU,EAAY,QACtB,EAAU,EAAY,QACtB,EAAU,EAAY,QACtB,EAAU,EAAY,QACtB,EAAU,EAAY,QAEtB,EAAM,OAAO,aACb,EAAM,CAAC,EAAG,IAAS,EAAE,WAAW,GAAQ,GAGvC,WAAe,EAAM,GAC1B,GAAI,MAAO,IAAY,SACrB,mBAAa,EAAM,GACZ,EAET,GAAI,GAAO,WAAY,GAAM,KACzB,EAAU,EAAa,EAAM,GACjC,MAAI,IAAQ,GACV,YAAa,EAAM,GAEd,EAIF,WAAsB,EAAM,GACjC,KAAM,GAAiB,sCACjB,EAAM,CAAC,EAAK,IAAM,GAAI,OAAM,GAAG,iBAAmB,OAAK,OAAO,KACpE,GAAI,GAAO,GACX,OAAS,KAAK,OAAM,QAAQ,GAAY,EAAW,CAAE,GACnD,EAAO,EAAK,OAAO,EAAE,OAAO,MAAM,aAEpC,OAAS,KAAK,IACZ,GAAI,GAAM,GACN,EAAM,GACN,EAAK,EACL,EAAO,EAEX,OAAS,GAAI,EAAG,EAAI,EAAE,OAAQ,KAC5B,GAAI,GAAI,EAAI,EAAG,GACf,GAAI,GAAM,EACR,OAAQ,OACD,SACA,SACA,KACH,AAAK,GACH,EAAI,KAAK,GAEX,UACG,IACH,EAAM,CAAE,IAAM,IAAM,KACpB,EAAM,GACN,UACG,QACA,QACA,IACH,EAAK,EACL,cAEA,GAAI,GAAM,EACR,KAAM,GAAI,+BAA+B,OAAK,EAAI,MAAO,GAE3D,UAGJ,QAAQ,OACD,KAAM,GAAQ,EAAM,UACpB,KAAM,GAAQ,EAAM,UACpB,KAAM,GAAQ,EAAM,cAChB,KAAM,GAAI,sBAAsB,OAAK,EAAI,MAAO,IAI/D,GAAI,GAAM,EACR,KAAM,GAAI,oBAAqB,GAEjC,AAAI,EAAI,QAAU,GAChB,GAAM,CAAE,MAEV,AAAI,GAAQ,GACV,GAAO,EAAM,EAAM,GAGrB,GAAI,GAAQ,EACZ,OAAS,KAAK,GACZ,OAAQ,OACD,KAAM,GAAU,GAAQ,EAAK,UAC7B,KAAM,GAAU,GAAQ,EAAK,UAC7B,KAAM,GAAS,EAAc,MAGtC,OAAQ,OACD,IAAM,GAAQ,EAAQ,UACtB,IAAM,GAAQ,CAAC,EAAQ,UACvB,IAAM,EAAO,EAAQ,OAS9B,MAAO,UC/GT,0BAAM,GAAc,CAAC,CAAC,QAAQ,OAAO,MAC/B,EAAc,CAAC,CAAC,QAAQ,OAAO,MAE9B,KAAM,GAAS,OACb,UACC,oBAED,GACL,MAAK,IAAM,GAAK,KACT,EAAG,OAAO,KAAK,MAAO,GAAO,MAAQ,GAAK,EAAG,WAIxD,GAAI,GAAe,GACjB,KAAM,GAAM,GAAe,QAAQ,QAAW,QAAQ,OAChD,EAAmB,KACvB,EAAO,MAAQ,EAAG,QAClB,EAAO,OAAS,EAAG,MAErB,EAAG,GAAG,SAAU,GAChB,IACA,EAAO,MAAQ,KAGb,EAAG,MAAM,cCxBb,6CAAoB,kBACpB,EAAsB,oBAEf,WAAkB,EAAK,EAAQ,EAAS,GAC7C,AAAI,IAAO,QACT,CAAI,IAAY,OAEd,GAAK,EACL,EAAS,MAGT,GAAK,EACL,EAAU,OAGd,AAAK,GAAW,GAAU,IAC1B,KAAM,GAAU,EAAQ,UAAY,OAAY,IAAM,EAAQ,QACxD,EAAY,CAAC,CAAC,EAAQ,UACtB,EAAe,GAAI,OACzB,GAAI,GAAQ,KACZ,KAAM,GAAW,CAAC,EAAI,KAEpB,GAAI,GAAU,CAAC,EAAO,KAAK,GACzB,OAEF,EAAa,IAAI,GACjB,AAAI,IAAU,MACZ,GAAQ,WAAW,KACjB,EAAQ,KACR,EAAG,MAAM,KAAK,IACd,EAAa,SACZ,KAGP,GAAI,GAAY,OAAM,QAAQ,GAAO,EAAM,CAAC,IAAM,IAAI,GACpD,QAAS,EAAK,WAAE,GAAa,IAE3B,EAAU,GACd,KAAM,GAAO,KACX,aAAa,GACb,AAAK,GACH,GAAU,GACV,EAAS,IAAI,GAAK,EAAE,WAGxB,MAAO,GAST,iBAA8B,EAAK,EAAQ,GACzC,AAAK,GAAW,GAAU,IAC1B,GAAI,CAAC,YAAe,CAAC,WAAY,QAE/B,KAAM,IAAI,OAAM,uCAElB,KAAM,GAAQ,GACR,EAAU,EACV,EAAU,GAAI,OACpB,iBAAqB,EAAK,GACxB,GAAI,EAAQ,IAAI,GAEd,OAEF,EAAQ,IAAI,GACZ,KAAM,GAAI,KAAM,YAAY,QAAQ,GAEpC,eAAiB,KAAO,IACtB,GAAI,GAAO,EAAI,KACf,AAAI,EAAI,cACN,AAAI,EAAQ,WACV,KAAM,GAAM,OAAU,EAAK,GAAO,OAAU,EAAQ,IAEjD,AAAI,GAAI,UAAY,EAAI,mBAC7B,CAAI,GAAU,EAAO,KAAK,IACxB,EAAM,KAAK,OAAU,EAAQ,MAKrC,MAAO,GAAM,UAAa,GAAM,KAAK,KAAK,IAAM,EAAM,eCpFxD,sEAAY,GAAU,oBACtB,GAAoB,kBAEpB,GAAiC,MACjC,GAAmC,MACnC,GAAuB,MAEvB,KAAM,SAAE,WAAS,IAAa,EAOvB,KAAM,GAAiB,CAC5B,KAAM,SACN,KAAM,SACN,KAAM,UACN,KAAM,UACN,KAAM,UACN,KAAM,UACN,KAAM,WAIR,WAAiB,GACf,GAAI,GAAU,GACV,EAAS,QAAQ,MACrB,AAAI,GAAO,QAAQ,MAAM,GACzB,IACE,EAAU,KAAQ,QAAQ,oBACnB,YAEP,AAAI,GAAO,QAAQ,MAAM,GAE3B,GAAI,GACF,KAAM,GAAO,MAAW,eAAiB,MACzC,GAAI,GAAI,EAAQ,QAAQ,GACxB,GAAI,GAAK,GACP,MAAO,QAAU,EAAQ,OAAO,EAAG,EAAI,EAAK,OAAS,MAAS,QAAS,OAAQ,OAInF,MAAO,MAIF,WAA0B,GAG/B,EAAM,UAAa,GACnB,KAAM,GAAO,QAAW,GAAK,KAC7B,QACE,GAAI,GAAO,OAAU,EAAK,iBAC1B,GAAI,cAAc,GAChB,MAAO,GAET,EAAM,EAAQ,GACd,GAAI,GAAO,EAET,MAGJ,MAAO,MAIT,KAAM,GAAU,EACV,EAAU,EACV,EAAU,EACV,EAAU,EAGV,EAAa,QAAC,OAAO,UAAK,QAAQ,GAGxC,WAAoB,EAAK,GACvB,OAAS,KAAK,QAAO,KAAK,IACxB,GAAI,GAAI,EAAW,OAAO,EAAI,IAAI,eAClC,GAAI,IAAM,OACR,KAAM,IAAI,OACR,6BAA6B,MAAM,QAAK,sCACxC,OAAO,KAAK,GAAY,IAAI,SAAM,KAAK,OAG3C,EAAI,GAAK,GASN,WAAgB,GACrB,AAAK,GAAW,GAAU,IAC1B,GAAI,GAAe,WACN,eAGT,EAAI,GAAI,SAAQ,CAAC,EAAS,KAE9B,GAAI,EAAQ,MAAQ,MAClB,MAAO,GAAQ,IAGjB,KAAM,GAAU,EAAQ,MAAQ,OAAS,QAAQ,IAAI,KAAK,SACpD,EAAM,EAAQ,KAAO,QAAQ,MAG7B,EACJ,EAAQ,MAAQ,KAAO,KACvB,EAAiB,EAAQ,OAAS,UAAa,EAAK,EAAQ,QAAU,GAExE,GAAI,EAAQ,MAAQ,MAAQ,CAAC,EAE3B,MAAO,GAAQ,IAIjB,GAAI,GAAU,EAAQ,EAAQ,KAC9B,GAAI,GAAW,OAAS,EAAQ,MAAQ,MAEtC,GAAI,CAAE,GAAU,cAAW,IAEzB,eAAQ,KACN,eAAY,OAAO,KAAO,KAAO,qFAEjC,WAAc,QAAQ,MAAO,EAAQ,IAAiB,0EAGjD,EAAQ,IAKnB,KAAM,GAAU,GAChB,EAAW,EAAS,GACpB,AAAI,EAAQ,OACV,EAAW,EAAS,EAAQ,OAI9B,GAAI,GAAO,CACT,WACA,EAAQ,QAAU,WAClB,EAAQ,OAAS,WACjB,OAAO,EAAQ,MAAQ,IAAI,OAAO,GAAK,GAGzC,KAAM,OAAE,IAAU,yBACZ,EAAI,GAAM,EAAS,EAAM,OACtB,CAAC,UAAW,OAAQ,eAC3B,IAII,EAAuB,KAC3B,IAAM,EAAE,aAAgB,MAE1B,QAAQ,GAAG,OAAQ,GAGnB,EAAa,OAAS,KAEpB,EAAE,QAGJ,KAAM,GAAa,GAAK,EAClB,EAAa,SAAM,OACnB,GAAa,SAAM,IACnB,GAAa,SAAM,MAEnB,GAAU,OAAO,KAAK,OACtB,GAAa,OAAO,KAAK,UACzB,GAAiB,OAAO,KAAK,MAC7B,GAA2B,OAAO,KAAK,wBAEvC,EAAW,GACjB,GAAI,GAAS,EACT,EAAmB,GACnB,EAAQ,QACF,WACE,QACH,UAEL,KAAK,OAAS,EACd,KAAK,SAAW,EAChB,KAAK,MAAQ,IAIb,EAAS,GAGb,aACE,GAAI,CAAC,EAAQ,OAAS,EAAM,QAAU,GACpC,EAAQ,OAAS,QAAQ,IAAI,UAAO,OAAO,QAC3C,GAAI,GAAU,GACd,AAAI,EAAM,OAAS,EACjB,EAAQ,KAAK,GAAW,OAAS,EAAO,UAAW,WAAY,EAAM,UAErE,EAAQ,KAAK,GAAQ,WAEvB,AAAI,EAAM,SAAW,GACnB,EAAQ,KAAK,EAAU,EAAO,YAAa,aAAc,EAAM,YAEjE,AAAI,EAAM,MAAQ,GAChB,EAAQ,KAAK,EAAO,YAAa,aAAc,EAAM,QAEvD,QAAQ,IAAI,EAAQ,KAAK,QACzB,EAAQ,OAAS,QAAQ,IAAI,UAAO,OAAO,QAE7C,EAAmB,EAAM,OAAS,EAClC,EAAQ,OAAS,EAAQ,MAAM,GAC/B,EAAM,QACN,EAAS,GAKX,WAAwB,GAGtB,KAAM,GAAQ,EAAS,QACvB,EAAS,OAAS,EAElB,GAAI,GAAU,GACZ,KAAM,GAAQ,EAAM,GACpB,GAAI,EAAM,SAAS,IACjB,SAAM,QAEC,GAA4B,IAC9B,GAAI,EAAM,MAAM,GAAQ,EAAK,QAAU,GAE5C,MAAO,IAA4B,SAGrC,KAAM,GAAU,uCAChB,GAAI,GAAQ,EAAM,QAAQ,SAAS,QACnC,OAAQ,EAAQ,QACT,GAAQ,MAAO,IAA4B,QAE3C,GAEH,EAAQ,EAAM,QAAQ,EAAS,EAAU,SACzC,EAAoB,EAAO,GAC3B,EAAM,QACN,UAEG,GAEH,EAAQ,EAAM,QAAQ,EAAS,EAAU,YACzC,EAAoB,EAAO,GAC3B,EAAM,WACN,cAGA,AAAI,EAAQ,KAAK,GACf,EAAM,SAEN,EAAM,QAER,MAEJ,QAAQ,OAAO,MAAM,GAIvB,EAAM,QAAQ,GAAK,QAAQ,OAAO,MAAM,IAExC,GAA4B,IAI9B,WAA6B,EAAO,GAClC,OAAS,GAAI,EAAG,EAAI,EAAM,OAAQ,KAChC,GAAI,GAAO,EAAM,GACjB,GAAI,EAAK,SAAS,MAChB,GAAI,GAAI,EAAK,SAAS,QACtB,EAAI,EAAE,QAAQ,qBAAsB,EAAQ,OAC5C,EAAM,GAAK,IAMjB,WAAgB,EAAU,EAAQ,GAChC,MAAQ,IAAK,EAAI,EAAW,GAAQ,QAAQ,MAAO,GAGrD,EAAW,EAAE,OAAQ,CAAC,EAAM,KAC1B,AAAK,EAAQ,aACX,GAAO,GAAmB,IAE5B,GAAI,GACF,AAAI,EAAK,OAAS,GAChB,EAAS,KAAK,GAEhB,AAAI,EAAS,OAAS,GACpB,IAEF,OAGF,AAAI,GAAU,EAAK,OAAS,GAG1B,GAAS,GACT,EAAQ,WAAa,EAAQ,aAG/B,GAAI,EAAK,SAAS,KAChB,GAAI,GAAI,GAAkB,EAAK,SAAS,SACxC,GAAI,iDAAiD,KAAK,IAExD,EAAe,IACf,EAAS,EACT,WAEA,GAAe,IAEjB,EAAS,UAGL,EAAK,SAAS,KAChB,KAAM,GAAI,EAAK,SAAS,QAClB,EAAI,0DAA0D,KAAK,GAEzE,GAAI,GAAU,EAAI,SAAS,EAAE,IAAM,EACnC,AAAI,EAAU,GAAK,CAAC,MAAM,IACxB,CAAI,EAAS,OAAS,GACpB,IAEF,EAAS,GAIf,EAAS,KAAK,KAOhB,EAAE,GAAG,QAAS,IAEZ,QAAQ,eAAe,OAAQ,GAC/B,EAAQ,CAAC,KAGX,YAA2B,GACzB,MAAO,GAAE,QAAQ,cAAe,IAGlC,YAA4B,GAE1B,GAAI,GAAI,EAAI,QAAQ,IACpB,MACE,IAAK,GAAK,EACV,GAAK,EAAI,EAAI,SAAS,GACtB,OAAO,OAAO,CAAC,EAAI,SAAS,EAAE,GAAI,EAAI,SAAS,EAAE,IAAK,EAAI,OAAS,MAIvE,SAAE,OAAS,IACT,CAAK,EAAa,WAChB,GAAa,UAAY,GACzB,EAAa,UAER,GAEF,EAGT,KAAM,GAAc,OAAO,YAAY,GAGvC,WAAoB,EAAG,GACrB,GAAI,GAAO,GAAI,EAAO,EACtB,KAAM,GAAU,IACd,GAAI,GAAO,EACX,QACE,GAAI,GAAI,EAAK,QAAQ,GAAM,GAC3B,GAAI,GAAK,IACP,GAAI,EAAO,EAAK,OAAS,GACvB,KAAM,GAAQ,EAAK,SAAS,GAC5B,EAAK,KAAK,GACV,GAAQ,EAAM,OAEhB,MAEF,IACA,GAAI,GAAM,EAAK,SAAS,EAAM,GAC9B,AAAI,EAAO,GACT,GAAM,OAAO,OAAO,EAAK,OAAO,GAAM,EAAO,EAAI,QACjD,EAAK,OAAS,EACd,EAAO,GAET,EAAO,EAAK,IACZ,EAAO,IAGL,EAAQ,KACZ,AAAI,EAAK,OAAS,EAChB,EAAO,OAAO,OAAO,EAAM,GAAO,IAElC,EAAO,EAAa,KAkBxB,EAAE,GAAG,OAAQ,GACb,EAAE,GAAG,QAAS,GACd,EAAE,GAAG,MAAO,aC3ad,KACA,IAAyB,uBACzB,GAAoB,kBACR,GAAU,oBAEtB,GAAgE,MAChE,GAAoC,MACpC,GAA8C,MAC9C,GAAoC,MACpC,GAAuB,MACvB,GAAkC,MAClC,GAAyD,MAEzD,KAAM,SAAE,WAAS,GAAa,GAExB,GAAQ;;;;;;;;;;;;;;;;EAmBR,EAAa,GACd,SAAc,SACV,KAAU,SACV,cACK,aACD,sBACS,cACR,aACD,QACL,SACC,oBACW,sBACE,IAIhB,EAAU,WACH,kDACI;;;;;iBAMD,QACJ,UACA,UACA,WACC,KAAO,KAOd,GAAkB,GAAI,KAAI,CAC9B,MACA,QACA,QACA,QACA,UACA,cACA,QACA,QACA,MACA,UACA,UAKI,EAAQ,SAAQ,IAAI,GAAM,SAAS,SAAS,SAAW,QAAQ,KAAK,GAAK,QAAQ,IAAI,EAQ3F,GAAI,GAAoB,GACxB,WAA0B,GACxB,GAAI,CAAC,GACH,EAAoB,GACpB,GAAI,GAAe,GAAQ,EAC3B,QAAQ,GAAG,OAAQ,IAAU,QAAQ,KAAK,GAAQ,MAKtD,YAAuB,GAErB,AAAK,EAAO,aACV,GAAO,YAAc,IAEvB,AAAI,EAAO,OACT,CAAI,MAAM,QAAQ,EAAO,OACvB,EAAO,YAAc,EAAO,YAAY,OAAO,EAAO,OAEtD,EAAO,YAAY,KAAK,EAAO,QAGnC,MAAO,GAAO,MACd,GAAI,EAAO,YAAY,QAAU,EAC/B,KAAM,IAAI,OAAM,0CAKlB,AAAI,EAAO,UACT,AAAI,EAAO,WAAa,UACtB,GAAO,UAAY,YAGrB,MAAO,GAAO,UAKlB,YAAkC,GAChC,GAAI,GAAiB,GACrB,OAAS,KAAK,QAAO,KAAK,GACxB,AAAK,GAAgB,IAAI,IACvB,GAAe,GAAK,EAAO,IAG/B,MAAO,GAIT,WAAe,EAAQ,GACrB,GAAU,QAAQ,MAAM,GAAG,MAAS,KACpC,GAAI,GAAM,GAAM,OAChB,AAAI,GACF,CAAI,EAAM,WACR,GAAM,EAAM,UAAY,EAAI,OAAO,EAAI,QAAQ;KAEjD,AAAI,EAAM,eACR,IAAO,EAAM,gBAGjB,EAAM,EAAI,QAAQ,SAAU,GAC5B,QAAQ,MAAM,EAAI,QAClB,QAAQ,KAAK,EAAS,EAAI,GAK5B,WAAkB,EAAS,EAAM,GAC/B,AAAI,GACF,GAAU,IAAK,KAAY,EAAM,eAGnC,KAAM,GAAO,IAAK,GACZ,EAAkB,GAAI,OAC5B,GAAI,GAAW,GACX,EAAI,EAER,WAAgB,EAAG,EAAI,GACrB,GAAI,GAAI,EAAQ,GAChB,KAAM,GAAI,MAAO,GACjB,GAAI,MAAO,IAAK,UACd,EAAK,GAAK,CAAC,OAEX,KAAM,GAAQ,EAAK,EAAK,EAAK,EAAE,GAC/B,AAAI,IAAU,QACZ,EAAM,4BAA4B,IAAY,GAEhD,AAAI,MAAM,QAAQ,GACd,GAAK,IAAO,GAAK,GAAK,KAAK,KAAK,GAElC,EAAK,GAAK,GAKhB,KAAO,EAAI,EAAK,OAAQ,KACtB,GAAI,GAAI,EAAK,GACb,GAAI,GAAK,MACP,EAAW,EAAS,OAAO,EAAK,MAAM,EAAI,IAC1C,MAEF,GAAI,EAAE,WAAW,MAAQ,GAAK,KAC5B,KAAM,CAAC,EAAE,GAAM,EAAE,QAAQ,OAAO,IAAI,MAAM,KAC1C,AAAI,IAAK,KAAO,GAAK,SACnB,EAAM,KAAM,GAEd,GAAI,CAAE,KAAK,KAET,GAAI,EAAE,IAAM,KAAO,CAAC,GAClB,GAAI,GAAI,EAAE,MAAM,IAChB,GAAI,EAAE,MAAM,GAAK,MAAO,GAAQ,IAAM,YACpC,EAAE,IAAI,GAAK,EAAO,EAAG,GAAI,IACzB,UAGJ,EAAM,kBAAkB,IAAK,GAE/B,EAAO,EAAG,EAAI,OAEd,GAAS,KAAK,GAGlB,MAAO,MAAE,OAAY,GAIvB,KAAM,GAAe,OAAO,gBAI5B,iBAAqB,EAAM,GACzB,GAAI,GAAa,GACjB,AAAI,IAAW,EACb,GAAS,GACT,EAAa,IAGb,CAAI,GAAU,GAAS,IAAI,IAC3B,GAAc,IAGhB,KAAM,MAAE,OAAM,GAAS,EAAS,EAAY,EAAM,EAAa,EAAU,MAEzE,AAAI,EAAK,qBACP,SAAQ,IAAI,YAAY,UAA+B,MACvD,QAAQ,KAAK,IAIf,GAAI,GACF,GAAI,EAAK,QAAU,GAEjB,GAAI,GAAW,KACf,IAAM,EAAW,cAAc,oBAAiB,QAAQ,cAAgB,IACxE,GAAI,GACF,GAAI,GAAQ,EAAS,OAAS,EAAS,QACvC,GAAI,EACF,GAAI,CAAC,MAAM,QAAQ,GACjB,EAAK,KAAK,OACL,QAAS,KAAK,GACnB,EAAK,KAAK,GAGd,AAAK,EAAK,SAAW,GAAK,QAAU,EAAS,SAC7C,AAAK,EAAK,SAAW,GAAK,OAAS,EAAS,QAE9C,AAAI,EAAK,QAAU,GACjB,EAAM,6BAA8B,GAGxC,EAAO,YAAc,EACrB,EAAO,QAAU,EAAK,GAAK,EAAK,SAAW,OAC3C,EAAO,OAAS,EAAK,QAAU,OAC/B,EAAO,OAAS,EAAK,QAAU,OAC/B,EAAO,OAAS,EAAK,QAAU,OAC/B,EAAO,IAAM,QAAQ,MAGvB,KAAM,GAAQ,EAAO,MAAQ,EAAK,MAAQ,CAAC,CAAE,GAAK,GAAK,EAAK,OAAS,EAAO,OACtE,EAAQ,EAAO,MAAQ,EAAK,MAAQ,CAAC,CAAE,GAAK,OAAS,EAAK,GAAK,EAAO,OACtE,EAAQ,EAAO,MAAQ,EAAK,MAAQ,CAAC,CAAE,GAAK,OAAS,EAAO,OAElE,AAAI,EAAO,QAAU,QACnB,CAAI,EAAO,MACT,EAAK,MAAQ,GAEb,EAAK,YAAc,IAIvB,KAAM,GAAY,EAAK,OAAU,GAAK,YAAc,GAAQ,QAC5D,SAAQ,aAAU,QAAQ,OAAQ,GAClC,eAAc,aAAU,QAAQ,OAAQ,GAExC,KAAM,GAAW,IAAI,IAAS,QAAQ,MAAM,eAAY,IAAI,GAAG,MAAU,GAAG,GACtE,EAAW,QAAQ,IAAI,KAAK,SAC5B,EAAW,EAAQ,OAAS,QAAQ,IAAI,KAAK,SAC7C,EAAc,EAAQ,OAAS,WAAQ,GACvC,EAAW,EAAK,kBAAoB,IACxC,GAAI,GAAI,IAAM,AAAK,MAAM,QAAQ,IAAM,GAAI,CAAC,IAC5C,QAAQ,MAAM,eAAY,KAAK,WAAY,GAAG,IAC5C,OAEE,GAAkB,CAAC,CAAC,EAAK,KAE/B,GAAI,GAAU,EAAK,WAAa,MAAQ,GAAkB,KAAO,OACjE,AAAI,EAAO,MAAQ,QAAa,EAAO,MAAQ,QAC7C,GAAW,EAAO,KAAO,EAAO,KAAO,MAAS,KAAO,OAGzD,GAAI,IAAmB,GAAW,MAChC,SACE,wFAEF,EAAiB,GACV,GAGT,KAAM,IACJ,EAAK,oBAAsB,SAC3B,EAAK,UAAY,WACjB,EAAO,UAET,AAAK,QAAQ,OAAO,OAClB,GAAK,YAAc,IAGrB,KAAM,GACJ,EAAO,IAAM,WAAa,EAAO,KACjC,QAAQ,YAAc,EAAQ,QAAQ,WAAW,WAAa,UAEhE,GAAI,GAAoB,QAAQ,OAC9B,GAAI,GAAK,YAAc,QAAQ,MAAO,GACtC,AAAI,EAAG,WAAW,KAAO,SACvB,GAAK,GAEP,EAAY,iCAAiC,KAE/C,EAAO,IAAM,EAEb,AAAK,EAAO,OACV,GAAO,MAAQ,EAAO,MAAQ,aAAU,EAAO,MAIjD,GAAI,IAAgB,EACpB,cACE,UAAO,QACP,GAAgB,WAIlB,GAAI,IAAU,EAAO,SAAY,SAG7B,EACF,EAAO,MAAQ,CAAC,EAAO,KACrB,KAAM,GAAI,EAAO,MAAM,EAAQ,GACzB,EAAS,GAAK,IAAM,OAAY,EAAgB,EACtD,MAAO,aAAa,SAAU,EAAE,KAAK,GAAU,KAC7C,CAAC,EAAG,IAAkB,EAG5B,GAAI,EAAO,aACT,GAAI,GAAa,EACjB,EAAQ,CAAC,EAAO,KACd,IACE,SAAM,EAAO,QAAS,EAAO,mBACtB,GACP,EAAS,qCAAuC,EAAI,SACpD,EAAiB,GAEnB,MAAO,GAAW,EAAO,IAK7B,YAAwB,EAAW,QAAE,WAAQ,IAC3C,EAAY,GACZ,KAAM,GAAU,EAAO,QACvB,GAAI,CAAC,EAEH,EAAS,EAAO,QAAQ,MAAO,IAC/B,EAAO,OAAS,GAAK,EAAQ,QAE7B,KAAM,GAAI,iBAAiB,KAAK,GAC1B,GAAO,eAAY,WAAU,GACnC,GAAI,IAAU,EACd,GAAI,IAAa,YACf,KAAM,GAAM,WAAa,GACnB,GAAO,QAAU,WAAa,GAAU,YAAc,EAAS,IACrE,GAAU,GAAG,OAAS,EAAI,OAAO,MAAM,EAAI,OAAO,UAEpD,EAAQ,SAAM,MAAM,SAAS,MAAa,KAAK,EAAI,EAAE,GAAK,SAAS,OAErE,MAAO,GAAM,UAAE,SAAkB,IAAM,IAIzC,YAAqB,EAAW,QAAE,WAAQ,SAAU,IAClD,SAAY,GACZ,QAAQ,MAAM,GACd,AAAI,EAAO,QAAU,GAEnB,EAAO,KAAK,MACJ,EAAO,gBACH,OAGd,AAAI,wBAAwB,KAAK,IAE/B,CAAK,GAAU,QAAQ,KAAK,IAEvB,EAAM,UAAE,SAAU,GAAU,IAIrC,GAAI,GAAS,OACJ,KACH,EAAO,QAAU,IAEvB,OAAS,KAAK,GACZ,EAAO,GAAK,QAAK,EAAO,IAI1B,KAAM,IAAiB,QAEb,CAAC,YACT,SACO,eAAY,QAAU,KAE1B,GAAyB,UAE5B,GAIF,oBACE,AAAI,GAAS,CAAC,EAAK,aACjB,KAGF,KAAM,GAAI,GAAQ,GAClB,AAAI,YAAa,UACf,KAAM,GAKR,KAAM,GAAS,QAAQ,MACvB,QAAQ,MAAM,GACd,KAAM,GAAiB,SAAc,IACrC,eAAQ,MAAM,GAEP,EAAe,KACpB,GAAe,KAAK,KAAM,YAC1B,GAAY,KAAK,KAAM,aAK3B,KAAM,IAAe,EAAK,KAAO,QAAQ,UAAY,KAGrD,GAAI,GAAgB,KAChB,EAAwB,GAC5B,GAAI,GAAW,OAGb,KAAM,GAAc,GAAS,EAAK,MAAQ,CAAC,EAAK,YAChD,EAAgB,WAAQ,WAAQ,OAC9B,QACA,cACA,SACQ,SAAM,QAAU,MACnB,OACC,SACE,EAAQ,EAAO,YAAY,UAC5B,EAAO,oBAGZ,AAAI,CAAC,EAAK,aAAe,WAAU,GAAgB,MAGjD,UAAO,WAIb,EAAwB,gBAAc,GACtC,GAAI,EAAK,KACP,MAAI,IACF,UAAO,QAEF,EAET,AAAK,GAEH,EAAc,MAAM,GAClB,GAAS,EAAE,OAAS,OAAO,IACpB,KAMb,GAAI,GAAK,KAAM,IACf,GAAI,CAAC,GACH,GAAI,GACF,GAAI,GACJ,AAAK,EAGH,CAAK,GACH,GAAe,WAAW,IACxB,EAAQ,0CAA2C,OAEvD,EAAK,KAAM,GAAc,MAAM,IAAM,KANrC,EAAc,SAQhB,aAAa,GAEf,GAAI,EACF,MAAK,IAAM,IACJ,EAEP,QAAQ,KAAK,EAAK,EAAI,GAO1B,EAAQ,iCACR,KAAM,IAAU,MAAM,KAAK,GAAI,KAC7B,EAAO,YAAY,IAAI,GAAM,EAAQ,WAAa,QAAU,EAAkB,QAEhF,EAAS,IAAK,CAAC,iBAAkB,KACjC,YAAS,GAAS,WAAY,WAAa,IAAQ,IACjD,EAAQ,EAAM,OAAS,kBAAmB,EAAM,KAAK,OACrD,OAMJ,WAAqB,GACnB,EAAE,OAAS,GAAK,QAAQ,IAAI,UAAY,EAAE,IAAI,GAAK,EAAE,MAAM,KAAK;IAIlE,cACE,MAAO,GAAM,QAAQ,KAAK,MAAM,GAAI,GAAc,MAAM,IACtD,QAAQ,MAAM,eAAY,IAAI,EAAO,KAAQ,GAAE,OAAS,KACxD,QAAQ,KAAK,KACZ,KAAK,KACN,QAAQ,KAAK,KAKjB,GACE,EAAO,IAAM,KACb,QAAQ,YAAc,EAAS,QAAQ,WAAW,UAAU,KAC9B,eAI9B,KACA,OAKF,KAAM,MAAO,OAAc,IAAY,EAAS,EAAY,QAAQ,KAAK,MAAM,IAE/E,EAAQ,MAAQ,CAAC,CAAE,GAAQ,OAAS,EAAQ,GAC5C,EAAQ,MAAQ,CAAC,CAAE,GAAQ,OAAS,EAAQ,GAI5C,EAAO,QAAU,MAEf,UACA,UACA,WAGA,WACA,WACA,oBACA,kBACA,yBACA,4BACA,mBACA,sBACA,4BACA,yBACA,wBACA,+BACA,0BAIM,GACJ,MAAO,GAAM,QAAQ,KAAK,MAAM,GAAI,GAAQ,MAAM,IAChD,QAAQ,MAAM,eAAY,IAAI,EAAO,KAAQ,GAAE,OAAS,KACxD,QAAQ,KAAK",
  "names": []
}
